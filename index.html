<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态图组合成工具</title>
    <!-- 引入gif.js库 -->
    <script src="gif.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            background-size: 400% 400%;
            animation: gradientBG 20s ease infinite;
            height: 100vh;
            position: relative;
            color: white;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .background-text {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
            pointer-events: none;
            user-select: none;
        }
        
        .background-text::before {
            content: "小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧";
            position: absolute;
            top: -145%;
            left: -20%;
            width: 300%;
            height: 300%;
            font-size: 6vw;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.1);
            transform: rotate(-30deg);
            line-height: 2;
            word-spacing: 2em;
            white-space: pre-wrap;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 95vw;
            height: 90vh;
            max-width: 1400px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(7px);
        }

        .preview-area {
            flex: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .preview-canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background: #000;
            width: auto;
            height: auto;
            object-fit: contain; /* 确保不同尺寸图片都能正确显示 */
        }

        .control-panel {
            flex: 2;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            height: 100%;
        }
        
        /* 自定义滚动条样式 */
        .control-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .control-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .control-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #6a11cb, #2575fc);
            border-radius: 4px;
        }
        
        .control-panel::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, #ff416c, #ff4b2b);
        }

        .panel-title {
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffc107, #e056fd);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5), 
                         0 0 30px rgba(78, 205, 196, 0.3), 
                         0 0 40px rgba(69, 183, 209, 0.2);
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        @keyframes gradientShift {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        .animation-selector {
            background: rgba(30, 30, 50, 0.8);
            padding: 20px;
            border-radius: 15px;
        }

        .animation-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .anim-btn {
            padding: 12px 15px;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(37, 117, 252, 0.3);
        }

        .anim-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(37, 117, 252, 0.5);
        }

        .anim-btn.active {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            box-shadow: 0 0 20px rgba(255, 65, 108, 0.6);
        }

        .upload-section {
            background: rgba(30, 30, 50, 0.8);
            padding: 20px;
            border-radius: 15px;
        }

        .upload-area {
            border: 3px dashed #4a86e8;
            border-radius: 10px;
            padding: 8px;
            text-align: center;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(74, 134, 232, 0.1);
            max-width: 400px;
            margin: 20px auto;
        }

        .upload-area:hover {
            background: rgba(74, 134, 232, 0.2);
        }

        .upload-icon {
            font-size: 24px;
            margin-bottom: 5px;
            color: #4a86e8;
        }
        
        .upload-area p {
            margin: 3px 0;
            font-size: 14px;
        }
        
        .upload-area p.small {
            font-size: 12px;
            color: #aaa;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .action-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .play-btn {
            background: linear-gradient(to right, #00b09b, #96c93d);
            color: white;
        }

        .save-btn {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .status-text {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: #aaa;
            min-height: 20px;
        }

        .preview-title {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 18px;
            color: #ffcc00;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }
        
        .user-image-preview {
            max-width: 100px;
            max-height: 100px;
            border: 2px solid #4a86e8;
            border-radius: 8px;
            margin: 15px auto;
            display: none;
        }
        
        .position-info {
            background: rgba(30, 30, 50, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 14px;
            text-align: center;
        }

        /* 响应式设计 */
        @media (max-width: 1200px) {
            .container {
                width: 98vw;
                height: 95vh;
            }
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
                width: 98vw;
                height: 95vh;
            }
            
            .preview-area {
                flex: 1;
                height: 40%;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .control-panel {
                flex: 1;
                height: 60%;
                padding: 20px;
            }
            
            .animation-buttons {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            
            .anim-btn {
                padding: 10px 8px;
                font-size: 12px;
            }
        }

        @media (max-width: 600px) {
            .container {
                width: 99vw;
                height: 98vh;
                border-radius: 15px;
            }
            
            .preview-area {
                height: 35%;
                padding: 15px;
            }
            
            .control-panel {
                height: 65%;
                padding: 15px;
                gap: 15px;
            }
            
            .panel-title {
                font-size: 22px;
            }
            
            .animation-buttons {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }
            
            .anim-btn {
                padding: 12px 8px;
                font-size: 11px;
                min-height: 44px; /* 触摸友好的最小高度 */
            }
            
            .speed-slider {
                height: 10px;
            }
            
            .speed-slider::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
            }
            
            .speed-slider::-moz-range-thumb {
                width: 18px;
                height: 18px;
            }
        }

        @media (max-width: 400px) {
            .animation-buttons {
                grid-template-columns: 1fr;
            }
            
            .preview-area {
                height: 30%;
            }
            
            .control-panel {
                height: 70%;
            }
            
            .panel-title {
                font-size: 18px;
            }
        }
        
        /* 新增进度条样式 */
        .progress-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #00b09b, #96c93d);
            width: 0%;
            transition: width 0.3s;
        }
        
        /* 速度控制滑条样式 */
        .speed-control {
            background: rgba(30, 30, 50, 0.8);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 15px;
        }
        
        .speed-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            margin: 10px 0;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .speed-info {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
        
        .speed-display {
            text-align: center;
            color: #ffcc00;
            font-weight: bold;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="background-text"></div>
    
    <div class="container">
        <div class="preview-area">
            <div class="preview-title">预览区域 - <span id="animName">玩法1</span></div>
            <canvas id="previewCanvas" class="preview-canvas" width="800" height="450"></canvas>
        </div>
        
        <div class="control-panel">
            <h2 class="panel-title">小笼包的玩法大全</h2>
            
            <div class="animation-selector">
                <h3>💗选择玩法💗</h3>
                <div class="animation-buttons" id="animationButtons">
                    <!-- 按钮将通过JavaScript动态生成 -->
                </div>
                
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">🤴</div>
                    <p>点击或拖放</p>
                    <p class="small">小笼包主人照片</p>
                </div>
                <img id="userImagePreview" class="user-image-preview" alt="用户上传的图片">
                <input type="file" id="imageUpload" accept="image/*" style="display: none;">
                <!--<div class="position-info">
                    <p id="framePositionInfo">当前帧位置: (400, 225) 旋转: 0°</p>
                </div>-->
            </div>
            
            <div class="speed-control">
                <h3>慢玩or冲刺</h3>
                
                <div class="speed-display" id="speedDisplay" style="margin-top: 15px;">1.0x 速度 (200ms/帧)</div>
                <input type="range" class="speed-slider" id="speedSlider" 
                       min="0.1" max="10" step="0.1" value="1">
                <div class="speed-info">
                    <span>0.1x (慢)</span>
                    <span>10x (快)</span>
                </div>
                
                <div class="speed-display" id="qualityDisplay" style="margin-top: 15px;">最高品质 (无噪点)</div>
                <input type="range" class="speed-slider" id="qualitySlider" 
                       min="1" max="30" step="1" value="30">
                <div class="speed-info">
                    <span>最低品质</span>
                    <span>最高品质</span>
                </div>
            </div>
            
            <div class="action-buttons" style="margin-top: 5px;">
                <button class="action-btn play-btn" id="testBtn">测试合成图片</button>
                <button class="action-btn save-btn" id="saveBtn">保存为GIF</button>
            </div>
            
            <div class="status-text" id="statusText">准备好创建您的动画！</div>
            <!-- 新增进度条 -->
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </div>
    </div>

    <script>
        // 配置信息
        const config = {
            // 按钮配置（可轻松添加/删除/修改）
            buttons: [
                { id: "1", text: "玩法1" },
                { id: "2", text: "玩法2" },
                { id: "3", text: "玩法3" },
                { id: "4", text: "玩法4" },
                { id: "5", text: "玩法5" },
                { id: "6", text: "玩法6" },
                { id: "7", text: "玩法7" },
                { id: "8", text: "玩法8" },
                { id: "9", text: "玩法9" },
                { id: "10", text: "玩法10" }
            ],
            
            // 动画帧配置
            // 每个玩法可以设置：
            // - canvasSize: { width: 宽度, height: 高度 } - 设置导出GIF的尺寸
            // - overlayPositions: 用户图片在每帧中的位置、旋转、缩放
            animations: {
                "1": {
                    name: "玩法1",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                        'image1/frame0.png',
                        'image1/frame1.png'
                    ],
                    // Canvas尺寸配置（可修改）
                    canvasSize: { width: 180, height: 140 },
                    // 每帧的叠加位置和旋转参数
                    overlayPositions: [
                        { x: 115, y: 55, rotation: 0, scale: 1 },
                        { x: 105, y: 50, rotation: 0, scale: 1 }
                    ]
                },
                "2": {
                    name: "玩法2",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 180, height: 140 },
                    overlayPositions: [
                        { x: 400, y: 180, rotation: 0, scale: 0.4 },
                        { x: 400, y: 200, rotation: 0, scale: 0.46 }
                    ]
                },
                "3": {
                    name: "玩法3",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 180, height: 140 },
                    overlayPositions: [
                        { x: 400, y: 200, rotation: 0, scale: 0.6 },
                        { x: 350, y: 200, rotation: 348, scale: 0.6 }
                    ]
                },
                "4": {
                    name: "玩法4",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 400, y: 280, rotation: 0, scale: 0.8 },
                        { x: 400, y: 140, rotation: 0, scale: 0.8 }
                    ]
                },
                "5": {
                    name: "玩法5",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 350, y: 200, rotation: -30, scale: 0.7 },
                        { x: 450, y: 200, rotation: 30, scale: 0.7 }
                    ]
                },
                "6": {
                    name: "玩法6",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 400, y: 200, rotation: 0, scale: 1.2 },
                        { x: 400, y: 200, rotation: 0, scale: 0.6 }
                    ]
                },
                "7": {
                    name: "玩法7",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 380, y: 180, rotation: 15, scale: 0.9 },
                        { x: 420, y: 220, rotation: -15, scale: 0.9 }
                    ]
                },
                "8": {
                    name: "玩法8",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 400, y: 200, rotation: 0, scale: 0.5 },
                        { x: 400, y: 200, rotation: 0, scale: 1.5 }
                    ]
                },
                "9": {
                    name: "玩法9",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 450, y: 160, rotation: 90, scale: 0.8 },
                        { x: 350, y: 240, rotation: 270, scale: 0.8 }
                    ]
                },
                "10": {
                    name: "玩法10",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 395, y: 200, rotation: -5, scale: 1.0 },
                        { x: 405, y: 210, rotation: 5, scale: 1.0 }
                    ]
                }
            }
        };

        // DOM 元素
        const dom = {
            canvas: document.getElementById('previewCanvas'),
            ctx: document.getElementById('previewCanvas').getContext('2d'),
            uploadArea: document.getElementById('uploadArea'),
            imageUpload: document.getElementById('imageUpload'),
            userImagePreview: document.getElementById('userImagePreview'),
            testBtn: document.getElementById('testBtn'),
            saveBtn: document.getElementById('saveBtn'),
            statusText: document.getElementById('statusText'),
            animName: document.getElementById('animName'),
            framePositionInfo: document.getElementById('framePositionInfo'),
            progressContainer: document.getElementById('progressContainer'),
            progressBar: document.getElementById('progressBar'),
            speedSlider: document.getElementById('speedSlider'),
            speedDisplay: document.getElementById('speedDisplay')
        };

        // 应用状态
        const state = {
            currentAnimation: '1',
            userImage: null,
            processedUserImage: null,
            isPlaying: false,
            currentFrame: 0,
            frameInterval: null,
            composedFrames: {},
            playSpeed: 1.0, // 播放速度倍数，1.0 = 200ms/帧
            gifQuality: 30, // GIF品质 (1-30, 数字越小品质越高)
            gif: null // gif.js实例
        };

        // 初始化函数
        function init() {
            // 添加这一行解决跨域问题
            dom.ctx = dom.canvas.getContext('2d', { willReadFrequently: true });
            
            // 初始化gif.js
            console.log('初始化gif.js库...');
            
            if (typeof GIF !== 'undefined') {
                console.log('✓ gif.js库加载成功');
            } else {
                console.error('✗ gif.js库加载失败');
            }
            
            setupButtons();
            setupEventListeners();
            setupSpeedControl();
            setupQualityControl();
            preloadFrameImages();
            renderFrame(0);
            // 自动开始播放动画
            startAnimation();
        }

        // 新增函数：处理用户图片
        function processUserImage() {
            if (!state.userImage) return;
            
            const anim = config.animations[state.currentAnimation];
            
            // 根据不同动画效果处理图片
            switch(state.currentAnimation) {
                case '1': // 旋转地球 - 处理为85像素直径的圆形
                    createCircularImage(state.userImage, 85).then(processedImg => {
                        state.processedUserImage = processedImg;
                        console.log('圆形图片处理完成');
                        renderFrame(state.currentFrame);
                    });
                    break;
                case '2': // 跳动心形 - 保持原样（可以后续扩展）
                case '3': // 旋转立方体 - 保持原样（可以后续扩展）
                default:
                    state.processedUserImage = state.userImage;
                    console.log('用户图片处理完成');
                    renderFrame(state.currentFrame);
                    break;
            }
        }

        // 新增函数：创建圆形图片
        function createCircularImage(sourceImage, diameter) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = diameter;
                canvas.height = diameter;
                
                // 计算缩放比例
                const sourceWidth = sourceImage.width;
                const sourceHeight = sourceImage.height;
                const minSide = Math.min(sourceWidth, sourceHeight);
                const scale = diameter / minSide;
                
                // 计算缩放后的尺寸
                const scaledWidth = sourceWidth * scale;
                const scaledHeight = sourceHeight * scale;
                
                // 计算居中位置
                const offsetX = (diameter - scaledWidth) / 2;
                const offsetY = (diameter - scaledHeight) / 2;
                
                // 创建圆形裁剪路径
                ctx.beginPath();
                ctx.arc(diameter / 2, diameter / 2, diameter / 2, 0, Math.PI * 2);
                ctx.clip();
                
                // 绘制缩放后的图片
                ctx.drawImage(sourceImage, offsetX, offsetY, scaledWidth, scaledHeight);
                
                // 创建新的Image对象返回
                const processedImage = new Image();
                processedImage.onload = () => resolve(processedImage);
                processedImage.src = canvas.toDataURL();
            });
        }

        // 修改preloadFrameImages函数，改进跨域处理
        function preloadFrameImages() {
            Object.keys(config.animations).forEach(animId => {
                const anim = config.animations[animId];
                anim.frameImages = [];
                
                for (let i = 0; i < anim.frameCount; i++) {
                    const img = new Image();
                    const url = anim.frameURLs[i];
                    
                    // 改进的跨域处理
                    if (url.startsWith('http')) {
                        img.crossOrigin = "anonymous";
                        img.src = url;
                    } else {
                        // 本地资源
                        img.src = url;
                    }
                    
                    img.onload = () => {
                        console.log(`图片加载成功: ${url}`);
                        dom.statusText.textContent = `加载中: ${anim.name} (${i+1}/${anim.frameCount})`;
                        if (i === anim.frameCount - 1) {
                            dom.statusText.textContent = `快开始迫害小笼包吧！`;
                        }
                    };
                    
                    img.onerror = () => {
                        console.error(`无法加载图片: ${url}`);
                        dom.statusText.textContent = `错误: 无法加载图片 ${i+1}`;
                        
                        // 如果是网络图片失败，尝试不使用crossOrigin
                        if (url.startsWith('http') && img.crossOrigin) {
                            console.log('尝试不使用crossOrigin重新加载...');
                            img.crossOrigin = null;
                            img.src = url;
                        }
                    };
                    
                    anim.frameImages.push(img);
                }
            });
        }

        // 设置动画选择按钮
        function setupButtons() {
            const container = document.querySelector('.animation-buttons');
            container.innerHTML = '';
            
            config.buttons.forEach(btn => {
                const button = document.createElement('button');
                button.className = `anim-btn ${btn.id === state.currentAnimation ? 'active' : ''}`;
                button.dataset.anim = btn.id;
                button.textContent = btn.text;
                button.addEventListener('click', () => {
                    document.querySelector('.anim-btn.active').classList.remove('active');
                    button.classList.add('active');
                    changeAnimation(btn.id);
                });
                container.appendChild(button);
            });
        }

        // 设置速度控制
        function setupSpeedControl() {
            dom.speedSlider.addEventListener('input', (e) => {
                const speed = parseFloat(e.target.value);
                state.playSpeed = speed;
                
                // 更新显示
                const frameTime = Math.round(200 / speed);
                dom.speedDisplay.textContent = `${speed.toFixed(1)}x 速度 (${frameTime}ms/帧)`;
                
                // 如果正在播放，重新启动动画以应用新速度
                if (state.isPlaying) {
                    stopAnimation();
                    startAnimation();
                }
                
                console.log(`速度调整为: ${speed}x, 帧间隔: ${frameTime}ms`);
            });
        }

        // 设置品质控制
        function setupQualityControl() {
            const qualitySlider = document.getElementById('qualitySlider');
            const qualityDisplay = document.getElementById('qualityDisplay');
            
            qualitySlider.addEventListener('input', (e) => {
                const sliderValue = parseInt(e.target.value);
                // 反转值：滑条从左到右（1-30），实际品质从低到高（30-1）
                const quality = 31 - sliderValue;
                state.gifQuality = quality;
                
                // 更新显示
                let qualityText;
                if (quality <= 3) {
                    qualityText = '最高品质';
                } else if (quality <= 10) {
                    qualityText = '高品质';
                } else if (quality <= 20) {
                    qualityText = '中品质';
                } else {
                    qualityText = '低品质';
                }
                
                qualityDisplay.textContent = `${qualityText} (${quality})`;
                
                console.log(`GIF品质调整为: ${quality}, 描述: ${qualityText}`);
            });
            
            // 初始化显示
            const initialSliderValue = parseInt(qualitySlider.value);
            const initialQuality = 31 - initialSliderValue;
            state.gifQuality = initialQuality;
            qualityDisplay.textContent = '最高品质 (' + initialQuality + ')';
        }

        // 设置事件监听器
        function setupEventListeners() {
            // 上传区域点击事件
            dom.uploadArea.addEventListener('click', () => dom.imageUpload.click());
            
            // 文件上传事件
            dom.imageUpload.addEventListener('change', handleImageUpload);
            
            // 测试按钮事件
            dom.testBtn.addEventListener('click', saveComposedImages);
            
            // 保存按钮事件
            dom.saveBtn.addEventListener('click', saveAsGif);
            
            // 允许拖放上传
            dom.uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dom.uploadArea.style.background = 'rgba(74, 134, 232, 0.3)';
            });
            
            dom.uploadArea.addEventListener('dragleave', () => {
                dom.uploadArea.style.background = 'rgba(74, 134, 232, 0.1)';
            });
            
            dom.uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dom.uploadArea.style.background = 'rgba(74, 134, 232, 0.1)';
                
                if (e.dataTransfer.files.length) {
                    dom.imageUpload.files = e.dataTransfer.files;
                    handleImageUpload();
                }
            });
        }

        // 处理图片上传
        function handleImageUpload() {
            const file = dom.imageUpload.files[0];
            if (!file) return;
            
            if (!file.type.match('image.*')) {
                dom.statusText.textContent = '请上传图片文件 (JPG, PNG)';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                state.userImage = new Image();
                state.userImage.src = e.target.result;
                state.userImage.onload = () => {
                    dom.statusText.textContent = '图片上传成功!';
                    
                    // 修复预览显示问题
                    const preview = dom.userImagePreview;
                    preview.src = state.userImage.src;
                    preview.style.display = 'block';
                    preview.onload = () => {
                        console.log('预览图片加载成功');
                    };
                    preview.onerror = () => {
                        console.error('预览图片加载失败');
                        preview.style.display = 'none';
                    };
                    
                    // 处理用户图片
                    console.log('开始处理用户图片');
                    processUserImage();
                    
                    // 清除缓存
                    state.composedFrames = {};
                };
            };
            reader.readAsDataURL(file);
        }

        // 更改当前动画
        function changeAnimation(animId) {
            stopAnimation();
            state.currentAnimation = animId;
            state.currentFrame = 0;
            dom.animName.textContent = config.animations[animId].name;
            
            // 重新处理用户图片（不同动画有不同处理方式）
            if (state.userImage) {
                console.log('切换动画，重新处理用户图片');
                processUserImage();
            } else {
                renderFrame(0);
            }
            
            dom.statusText.textContent = `已选择: ${config.animations[animId].name}`;
            
            // 自动开始播放新动画
            startAnimation();
        }

        // 渲染指定帧 - 使用配置的canvas尺寸
        function renderFrame(frameIndex) {
            const anim = config.animations[state.currentAnimation];
            const canvas = dom.canvas;
            const ctx = dom.ctx;
            
            // 使用配置的canvas尺寸
            const canvasWidth = anim.canvasSize ? anim.canvasSize.width : 800;
            const canvasHeight = anim.canvasSize ? anim.canvasSize.height : 450;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景图片
            if (anim.frameImages[frameIndex] && anim.frameImages[frameIndex].complete) {
                const img = anim.frameImages[frameIndex];
                
                // 将背景图片缩放到canvas尺寸
                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                
                console.log(`Canvas尺寸: ${canvasWidth}x${canvasHeight}, 背景图片: ${img.naturalWidth}x${img.naturalHeight}`);
            } else {
                // 如果图片未加载完成，显示占位背景
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`加载中: ${anim.name} 帧 ${frameIndex+1}`, canvas.width/2, canvas.height/2);
                
                console.log('背景图片未加载完成，使用配置尺寸');
            }
            
            // 绘制用户图片
            if (state.userImage && state.processedUserImage) {
                const pos = anim.overlayPositions[frameIndex];
                
                console.log(`绘制用户图片 - 帧${frameIndex}: 位置(${pos.x}, ${pos.y}), 旋转${pos.rotation}°, 缩放${pos.scale}`);
                
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.rotation * Math.PI / 180);
                
                // 绘制处理后的用户图片
                const imgWidth = state.processedUserImage.width * pos.scale;
                const imgHeight = state.processedUserImage.height * pos.scale;
                
                ctx.drawImage(
                    state.processedUserImage, 
                    -imgWidth/2, 
                    -imgHeight/2,
                    imgWidth,
                    imgHeight
                );
                
                ctx.restore();
                
                // 更新位置信息
                if (dom.framePositionInfo) {
                    dom.framePositionInfo.textContent = 
                        `当前帧位置: (${pos.x}, ${pos.y}) 旋转: ${pos.rotation}°`;
                }
            } else {
                console.log('用户图片未准备好:', !!state.userImage, !!state.processedUserImage);
            }
        }


        // 开始播放动画
        function startAnimation() {
            if (state.isPlaying) {
                return; // 如果已经在播放，不重复启动
            }
            
            const anim = config.animations[state.currentAnimation];
            state.isPlaying = true;
            
            // 计算播放间隔：基础200ms除以速度倍数
            const frameInterval = 200 / state.playSpeed;
            
            console.log(`开始播放动画: ${anim.name}, 帧数: ${anim.frameCount}, 速度: ${state.playSpeed}x, 间隔: ${frameInterval}ms`);
            
            state.frameInterval = setInterval(() => {
                state.currentFrame = (state.currentFrame + 1) % anim.frameCount;
                console.log(`切换到帧: ${state.currentFrame}`);
                renderFrame(state.currentFrame);
            }, frameInterval);
        }

        // 停止播放动画
        function stopAnimation() {
            if (state.frameInterval) {
                clearInterval(state.frameInterval);
                state.frameInterval = null;
            }
            state.isPlaying = false;
        }

        // 合成并保存图片到images文件夹用于测试
        async function saveComposedImages() {
            if (!state.userImage || !state.userImage.complete) {
                updateProgress('请先上传图片！');
                return;
            }
            
            const anim = config.animations[state.currentAnimation];
            const { width: canvasWidth, height: canvasHeight } = getBackgroundDimensions();
            
            try {
                for (let i = 0; i < anim.frameCount; i++) {
                    updateProgress(`正在合成第 ${i + 1}/${anim.frameCount} 帧...`);
                    
                    // 使用公共的帧合成函数
                    const compositeCanvas = await createCompositeFrame(i, canvasWidth, canvasHeight);
                    
                    // 转换为blob并下载
                    const blob = await new Promise(resolve => {
                        compositeCanvas.toBlob(resolve, 'image/png', 1.0);
                    });
                    
                    const fileName = `composed_frame_${i}.png`;
                    downloadImage(blob, fileName);
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                updateProgress('合成图片保存完成！');
            } catch (error) {
                console.error('合成图片失败:', error);
                updateProgress('合成图片失败');
            }
        }
        
        // 通用下载函数
        function downloadFile(blob, fileName, fileType = 'image/png') {
            try {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                return true;
            } catch (error) {
                console.error(`下载${fileType}失败:`, error);
                return false;
            }
        }
        
        // 下载单张图片
        function downloadImage(blob, fileName) {
            return downloadFile(blob, fileName, 'PNG图片');
        }
        
        // 获取canvas尺寸的通用函数
        function getBackgroundDimensions(animationId) {
            const anim = config.animations[animationId || state.currentAnimation];
            
            // 优先使用配置的canvas尺寸
            if (anim.canvasSize) {
                return { width: anim.canvasSize.width, height: anim.canvasSize.height };
            }
            
            // 备用：使用背景图片原始尺寸
            if (anim.frameImages[0] && anim.frameImages[0].complete) {
                return { width: anim.frameImages[0].naturalWidth, height: anim.frameImages[0].naturalHeight };
            }
            
            // 默认尺寸
            return { width: 800, height: 450 };
        }
        
        // 更新状态文本和进度的通用函数
        function updateProgress(text, progress = null) {
            dom.statusText.textContent = text;
            if (progress !== null) {
                dom.progressBar.style.width = `${progress}%`;
            }
        }
        
        // 使用gif.js保存GIF
        async function saveAsGif() {
            if (!state.userImage || !state.userImage.complete) {
                updateProgress('请先上传图片！');
                return;
            }
            
            updateProgress('正在生成GIF...', 0);
            dom.saveBtn.disabled = true;
            dom.testBtn.disabled = true; // 也禁用测试按钮
            dom.progressContainer.style.display = 'block';
            
            try {
                const anim = config.animations[state.currentAnimation];
                const { width: canvasWidth, height: canvasHeight } = getBackgroundDimensions();
                
                // 生成所有帧的canvas数组
                const frameCanvases = [];
                
                for (let i = 0; i < anim.frameCount; i++) {
                    updateProgress(`正在处理第 ${i + 1}/${anim.frameCount} 帧...`, ((i + 1) / anim.frameCount) * 30);
                    
                    const frameCanvas = await createCompositeFrame(i, canvasWidth, canvasHeight);
                    frameCanvases.push(frameCanvas);
                    
                    // 增加帧间处理延迟，避免阻塞UI
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                console.log(`准备生成GIF: ${frameCanvases.length}帧, 尺寸: ${canvasWidth}x${canvasHeight}`);
                
                updateProgress('正在使用gif.js生成GIF文件...', 40);
                
                const frameDelay = Math.round(200 / state.playSpeed);
                
                // 根据品质调整gif.js参数
                const optimizedQuality = state.gifQuality === 1 ? 1 : Math.max(1, Math.min(10, state.gifQuality));
                console.log(`使用优化品质: ${optimizedQuality}`);
                
                // 创建gif.js实例 - 优化配置减少噪点
                const gif = new GIF({
                    workers: 2, // 使用2个workers提高性能
                    quality: optimizedQuality, // 使用优化的品质值
                    width: canvasWidth,
                    height: canvasHeight,
                    repeat: 0, // 无限循环
                    transparent: null,
                    background: '#000000',
                    dither: false, // 关闭抖动算法，这是关键！
                    globalPalette: false, // 使用局部调色板，每帧独立
                    debug: false // 关闭调试信息
                });
                
                // 设置进度回调
                gif.on('progress', function(p) {
                    const progress = 40 + (p * 50);
                    updateProgress(`生成GIF中... ${Math.round(progress)}%`, progress);
                });
                
                // 设置完成回调
                gif.on('finished', function(blob) {
                    console.log(`gif.js成功生成GIF: ${(blob.size/1024).toFixed(1)}KB`);
                    
                    // 成功生成GIF
                    const fileName = `${anim.name.replace(/\s+/g, '_')}_动画_${state.playSpeed}x速度.gif`;
                    const success = downloadFile(blob, fileName, 'GIF动画');
                    
                    if (success) {
                        updateProgress('GIF保存成功！', 100);
                        console.log(`GIF下载成功: ${fileName}, 大小: ${(blob.size / 1024 / 1024).toFixed(2)}MB`);
                    } else {
                        updateProgress('下载失败，请重试');
                    }
                    
                    setTimeout(resetSaveButton, 2000);
                });
                
                // 设置错误回调
                gif.on('error', function(error) {
                    console.error('gif.js生成失败:', error);
                    updateProgress('GIF生成失败，正在下载图片序列...');
                    downloadFrameSequence(frameCanvases, anim.name);
                });
                
                // 添加所有帧到gif - 确保每帧独立
                for (let i = 0; i < frameCanvases.length; i++) {
                    const canvas = frameCanvases[i];
                    
                    // 创建独立的canvas副本，避免引用问题
                    const independentCanvas = document.createElement('canvas');
                    independentCanvas.width = canvas.width;
                    independentCanvas.height = canvas.height;
                    const ctx = independentCanvas.getContext('2d');
                    
                    // 确保完全清除画布
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // 复制原始画布内容
                    ctx.drawImage(canvas, 0, 0);
                    
                    gif.addFrame(independentCanvas, { 
                        delay: frameDelay,
                        copy: true, // 复制像素数据
                        dispose: 2 // 恢复到背景色
                    });
                    
                    console.log(`添加帧 ${i + 1}/${frameCanvases.length}`);
                }
                
                // 开始渲染
                console.log('开始gif.js渲染...');
                gif.render();
                
            } catch (error) {
                console.error('GIF生成失败:', error);
                updateProgress(`GIF生成失败: ${error.message}`);
                resetSaveButton();
            }
        }
        
        // 创建合成帧 - 优化减少噪点
        async function createCompositeFrame(frameIndex, canvasWidth, canvasHeight) {
            const anim = config.animations[state.currentAnimation];
            
            // 创建合成canvas，使用配置的尺寸
            const compositeCanvas = document.createElement('canvas');
            compositeCanvas.width = canvasWidth;
            compositeCanvas.height = canvasHeight;
            const ctx = compositeCanvas.getContext('2d', { 
                alpha: false, // 禁用透明度，减少噪点
                willReadFrequently: false 
            });
            
            // 强制清除并设置黑色背景
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // 设置高质量渲染
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // 绘制背景图片 - 与预览逻辑完全一致
            if (anim.frameImages[frameIndex] && anim.frameImages[frameIndex].complete) {
                const bgImg = anim.frameImages[frameIndex];
                
                // 确保图片完全覆盖画布
                ctx.drawImage(bgImg, 0, 0, canvasWidth, canvasHeight);
            }
            
            // 绘制用户图片 - 与预览逻辑完全一致
            if (state.processedUserImage && state.processedUserImage.complete) {
                const pos = anim.overlayPositions[frameIndex];
                
                console.log(`导出帧${frameIndex}: 用户图片位置(${pos.x}, ${pos.y}), 画布尺寸${canvasWidth}x${canvasHeight}`);
                
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.rotation * Math.PI / 180);
                
                const imgWidth = state.processedUserImage.width * pos.scale;
                const imgHeight = state.processedUserImage.height * pos.scale;
                
                // 使用高质量绘制
                ctx.drawImage(
                    state.processedUserImage,
                    -imgWidth/2,
                    -imgHeight/2,
                    imgWidth,
                    imgHeight
                );
                ctx.restore();
            }
            
            return compositeCanvas;
        }
        
        
        // 下载帧序列
        async function downloadFrameSequence(frameCanvases, animName) {
            for (let i = 0; i < frameCanvases.length; i++) {
                const canvas = frameCanvases[i];
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png', 1.0);
                });
                
                const fileName = `${animName.replace(/\s+/g, '_')}_frame_${i}.png`;
                downloadFile(blob, fileName, 'PNG图片');
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            updateProgress('图片序列下载完成！请使用其他工具制作GIF', 100);
            setTimeout(resetSaveButton, 3000);
        }
        
        // 重置保存按钮状态
        function resetSaveButton() {
            dom.saveBtn.disabled = false;
            dom.testBtn.disabled = false; // 重新启用测试按钮
            dom.progressContainer.style.display = 'none';
            dom.progressBar.style.width = '0%';
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>