<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态图组合成工具</title>
    <!-- 引入gifshot库 - 高质量GIF导出 -->
    <script src="https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            background-size: 400% 400%;
            animation: gradientBG 20s ease infinite;
            height: 100vh;
            position: relative;
            color: white;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .background-text {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
            pointer-events: none;
            user-select: none;
        }
        
        .background-text::before {
            content: "小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧";
            position: absolute;
            top: -145%;
            left: -20%;
            width: 300%;
            height: 300%;
            font-size: 6vw;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.1);
            transform: rotate(-30deg);
            line-height: 2;
            word-spacing: 2em;
            white-space: pre-wrap;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 95vw;
            height: 90vh;
            max-width: 1400px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(7px);
        }

        .preview-area {
            flex: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .preview-canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background: #000;
            width: auto;
            height: auto;
            object-fit: contain; /* 确保不同尺寸图片都能正确显示 */
        }

        .control-panel {
            flex: 2;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            height: 100%;
        }
        
        /* 自定义滚动条样式 */
        .control-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .control-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .control-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #6a11cb, #2575fc);
            border-radius: 4px;
        }
        
        .control-panel::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, #ff416c, #ff4b2b);
        }

        .panel-title {
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffc107, #e056fd);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5), 
                         0 0 30px rgba(78, 205, 196, 0.3), 
                         0 0 40px rgba(69, 183, 209, 0.2);
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        @keyframes gradientShift {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        .animation-selector {
            background: rgba(30, 30, 50, 0.8);
            padding: 20px;
            border-radius: 15px;
        }

        .animation-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .anim-btn {
            padding: 12px 15px;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(37, 117, 252, 0.3);
        }

        .anim-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(37, 117, 252, 0.5);
        }

        .anim-btn.active {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            box-shadow: 0 0 20px rgba(255, 65, 108, 0.6);
        }

        .upload-section {
            background: rgba(30, 30, 50, 0.8);
            padding: 20px;
            border-radius: 15px;
        }

        .upload-area {
            border: 3px dashed #4a86e8;
            border-radius: 10px;
            padding: 8px;
            text-align: center;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(74, 134, 232, 0.1);
            max-width: 400px;
            margin: 20px auto;
        }

        .upload-area:hover {
            background: rgba(74, 134, 232, 0.2);
        }

        .upload-icon {
            font-size: 24px;
            margin-bottom: 5px;
            color: #4a86e8;
        }
        
        .upload-area p {
            margin: 3px 0;
            font-size: 14px;
        }
        
        .upload-area p.small {
            font-size: 12px;
            color: #aaa;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .action-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .play-btn {
            background: linear-gradient(to right, #00b09b, #96c93d);
            color: white;
        }

        .save-btn {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .status-text {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: #aaa;
            min-height: 20px;
        }

        .preview-title {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 18px;
            color: #ffcc00;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }
        
        .user-image-preview {
            max-width: 100px;
            max-height: 100px;
            border: 2px solid #4a86e8;
            border-radius: 8px;
            margin: 15px auto;
            display: none;
        }
        
        .position-info {
            background: rgba(30, 30, 50, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 14px;
            text-align: center;
        }

        /* 响应式设计 */
        @media (max-width: 1200px) {
            .container {
                width: 98vw;
                height: 95vh;
            }
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
                width: 98vw;
                height: 95vh;
            }
            
            .preview-area {
                flex: 1;
                height: 40%;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .control-panel {
                flex: 1;
                height: 60%;
                padding: 20px;
            }
            
            .animation-buttons {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            
            .anim-btn {
                padding: 10px 8px;
                font-size: 12px;
            }
        }

        @media (max-width: 600px) {
            .container {
                width: 99vw;
                height: 98vh;
                border-radius: 15px;
            }
            
            .preview-area {
                height: 35%;
                padding: 15px;
            }
            
            .control-panel {
                height: 65%;
                padding: 15px;
                gap: 15px;
            }
            
            .panel-title {
                font-size: 22px;
            }
            
            .animation-buttons {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }
            
            .anim-btn {
                padding: 12px 8px;
                font-size: 11px;
                min-height: 44px; /* 触摸友好的最小高度 */
            }
            
            .speed-slider {
                height: 10px;
            }
            
            .speed-slider::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
            }
            
            .speed-slider::-moz-range-thumb {
                width: 18px;
                height: 18px;
            }
        }

        @media (max-width: 400px) {
            .animation-buttons {
                grid-template-columns: 1fr;
            }
            
            .preview-area {
                height: 30%;
            }
            
            .control-panel {
                height: 70%;
            }
            
            .panel-title {
                font-size: 18px;
            }
        }
        
        /* 新增进度条样式 */
        .progress-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #00b09b, #96c93d);
            width: 0%;
            transition: width 0.3s;
        }
        
        /* 速度控制滑条样式 */
        .speed-control {
            background: rgba(30, 30, 50, 0.8);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 15px;
        }
        
        .speed-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            margin: 10px 0;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .speed-info {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
        
        .speed-display {
            text-align: center;
            color: #ffcc00;
            font-weight: bold;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="background-text"></div>
    
    <div class="container">
        <div class="preview-area">
            <div class="preview-title">预览区域 - <span id="animName">玩法1</span></div>
            <canvas id="previewCanvas" class="preview-canvas" width="800" height="450"></canvas>
        </div>
        
        <div class="control-panel">
            <h2 class="panel-title">小笼包的玩法大全</h2>
            
            <div class="animation-selector">
                <h3>💗选择玩法💗</h3>
                <div class="animation-buttons" id="animationButtons">
                    <!-- 按钮将通过JavaScript动态生成 -->
                </div>
                
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">🤴</div>
                    <p>点击或拖放</p>
                    <p class="small">小笼包主人照片</p>
                </div>
                <img id="userImagePreview" class="user-image-preview" alt="用户上传的图片">
                <input type="file" id="imageUpload" accept="image/*" style="display: none;">
                <!--<div class="position-info">
                    <p id="framePositionInfo">当前帧位置: (400, 225) 旋转: 0°</p>
                </div>-->
            </div>
            
            <div class="speed-control">
                <h3>慢玩or冲刺</h3>
                
                <div class="speed-display" id="speedDisplay" style="margin-top: 15px;">1.0x 速度 (200ms/帧)</div>
                <input type="range" class="speed-slider" id="speedSlider" 
                       min="0.1" max="10" step="0.1" value="1">
                <div class="speed-info">
                    <span>0.1x (慢)</span>
                    <span>10x (快)</span>
                </div>
                
            </div>
            
            <div class="action-buttons" style="margin-top: 5px;">
                <button class="action-btn play-btn" id="testBtn">测试合成图片</button>
                <button class="action-btn save-btn" id="saveBtn">保存为GIF</button>
            </div>
            
            <div class="status-text" id="statusText">准备好创建您的动画！</div>
            <!-- 新增进度条 -->
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </div>
    </div>

    <script>
        // 配置信息
        const config = {
            // 按钮配置（可轻松添加/删除/修改）
            buttons: [
                { id: "1", text: "玩法1" },
                { id: "2", text: "玩法2" },
                { id: "3", text: "玩法3" },
                { id: "4", text: "玩法4" },
                { id: "5", text: "玩法5" },
                { id: "6", text: "玩法6" },
                { id: "7", text: "玩法7" },
                { id: "8", text: "玩法8" },
                { id: "9", text: "玩法9" },
                { id: "10", text: "玩法10" }
            ],
            
            // 动画帧配置
            // 每个玩法可以设置：
            // - canvasSize: { width: 宽度, height: 高度 } - 设置导出GIF的尺寸
            // - overlayPositions: 用户图片在每帧中的位置、旋转、缩放
            animations: {
                "1": {
                    name: "玩法1",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                        'image1/frame0.png',
                        'image1/frame1.png'
                    ],
                    // Canvas尺寸配置（可修改）
                    canvasSize: { width: 180, height: 140 },
                    // 每帧的叠加位置和旋转参数
                    overlayPositions: [
                        { x: 115, y: 55, rotation: 0, scale: 1 },
                        { x: 105, y: 50, rotation: 0, scale: 1 }
                    ]
                },
                "2": {
                    name: "玩法2",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 180, height: 140 },
                    overlayPositions: [
                        { x: 400, y: 180, rotation: 0, scale: 0.4 },
                        { x: 400, y: 200, rotation: 0, scale: 0.46 }
                    ]
                },
                "3": {
                    name: "玩法3",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 180, height: 140 },
                    overlayPositions: [
                        { x: 400, y: 200, rotation: 0, scale: 0.6 },
                        { x: 350, y: 200, rotation: 348, scale: 0.6 }
                    ]
                },
                "4": {
                    name: "玩法4",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 400, y: 280, rotation: 0, scale: 0.8 },
                        { x: 400, y: 140, rotation: 0, scale: 0.8 }
                    ]
                },
                "5": {
                    name: "玩法5",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 350, y: 200, rotation: -30, scale: 0.7 },
                        { x: 450, y: 200, rotation: 30, scale: 0.7 }
                    ]
                },
                "6": {
                    name: "玩法6",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 400, y: 200, rotation: 0, scale: 1.2 },
                        { x: 400, y: 200, rotation: 0, scale: 0.6 }
                    ]
                },
                "7": {
                    name: "玩法7",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 380, y: 180, rotation: 15, scale: 0.9 },
                        { x: 420, y: 220, rotation: -15, scale: 0.9 }
                    ]
                },
                "8": {
                    name: "玩法8",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 400, y: 200, rotation: 0, scale: 0.5 },
                        { x: 400, y: 200, rotation: 0, scale: 1.5 }
                    ]
                },
                "9": {
                    name: "玩法9",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 450, y: 160, rotation: 90, scale: 0.8 },
                        { x: 350, y: 240, rotation: 270, scale: 0.8 }
                    ]
                },
                "10": {
                    name: "玩法10",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 395, y: 200, rotation: -5, scale: 1.0 },
                        { x: 405, y: 210, rotation: 5, scale: 1.0 }
                    ]
                }
            }
        };

        // DOM 元素
        const dom = {
            canvas: document.getElementById('previewCanvas'),
            ctx: document.getElementById('previewCanvas').getContext('2d'),
            uploadArea: document.getElementById('uploadArea'),
            imageUpload: document.getElementById('imageUpload'),
            userImagePreview: document.getElementById('userImagePreview'),
            testBtn: document.getElementById('testBtn'),
            saveBtn: document.getElementById('saveBtn'),
            statusText: document.getElementById('statusText'),
            animName: document.getElementById('animName'),
            framePositionInfo: document.getElementById('framePositionInfo'),
            progressContainer: document.getElementById('progressContainer'),
            progressBar: document.getElementById('progressBar'),
            speedSlider: document.getElementById('speedSlider'),
            speedDisplay: document.getElementById('speedDisplay')
        };

        // 应用状态
        const state = {
            currentAnimation: '1',
            userImage: null,
            processedUserImage: null,
            isPlaying: false,
            currentFrame: 0,
            frameInterval: null,
            composedFrames: {},
            playSpeed: 1.0 // 播放速度倍数，1.0 = 200ms/帧
        };

        // 初始化函数
        function init() {
            // 添加这一行解决跨域问题
            dom.ctx = dom.canvas.getContext('2d', { willReadFrequently: true });
            
            // 初始化gifshot库检测
            console.log('初始化gifshot库...');
            
            if (typeof gifshot !== 'undefined' && gifshot && gifshot.createGIF) {
                console.log('✓ gifshot库加载成功');
            } else {
                console.warn('✗ gifshot库未就绪，将在导出时动态加载');
            }
            
            setupButtons();
            setupEventListeners();
            setupSpeedControl();
            preloadFrameImages();
            renderFrame(0);
            // 自动开始播放动画
            startAnimation();
        }

        // 新增函数：处理用户图片
        function processUserImage() {
            if (!state.userImage) return;
            
            const anim = config.animations[state.currentAnimation];
            
            // 根据不同动画效果处理图片
            switch(state.currentAnimation) {
                case '1': // 旋转地球 - 处理为85像素直径的圆形
                    createCircularImage(state.userImage, 85).then(processedImg => {
                        state.processedUserImage = processedImg;
                        console.log('圆形图片处理完成');
                        renderFrame(state.currentFrame);
                    });
                    break;
                case '2': // 跳动心形 - 保持原样（可以后续扩展）
                case '3': // 旋转立方体 - 保持原样（可以后续扩展）
                default:
                    state.processedUserImage = state.userImage;
                    console.log('用户图片处理完成');
                    renderFrame(state.currentFrame);
                    break;
            }
        }

        // 新增函数：创建圆形图片
        function createCircularImage(sourceImage, diameter) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = diameter;
                canvas.height = diameter;
                
                // 计算缩放比例
                const sourceWidth = sourceImage.width;
                const sourceHeight = sourceImage.height;
                const minSide = Math.min(sourceWidth, sourceHeight);
                const scale = diameter / minSide;
                
                // 计算缩放后的尺寸
                const scaledWidth = sourceWidth * scale;
                const scaledHeight = sourceHeight * scale;
                
                // 计算居中位置
                const offsetX = (diameter - scaledWidth) / 2;
                const offsetY = (diameter - scaledHeight) / 2;
                
                // 创建圆形裁剪路径
                ctx.beginPath();
                ctx.arc(diameter / 2, diameter / 2, diameter / 2, 0, Math.PI * 2);
                ctx.clip();
                
                // 绘制缩放后的图片
                ctx.drawImage(sourceImage, offsetX, offsetY, scaledWidth, scaledHeight);
                
                // 创建新的Image对象返回
                const processedImage = new Image();
                processedImage.onload = () => resolve(processedImage);
                processedImage.src = canvas.toDataURL();
            });
        }

        // 修改preloadFrameImages函数，改进跨域处理
        function preloadFrameImages() {
            Object.keys(config.animations).forEach(animId => {
                const anim = config.animations[animId];
                anim.frameImages = [];
                
                for (let i = 0; i < anim.frameCount; i++) {
                    const img = new Image();
                    const url = anim.frameURLs[i];
                    
                    // 改进的跨域处理
                    if (url.startsWith('http')) {
                        img.crossOrigin = "anonymous";
                        img.src = url;
                    } else {
                        // 本地资源
                        img.src = url;
                    }
                    
                    img.onload = () => {
                        console.log(`图片加载成功: ${url}`);
                        dom.statusText.textContent = `加载中: ${anim.name} (${i+1}/${anim.frameCount})`;
                        if (i === anim.frameCount - 1) {
                            dom.statusText.textContent = `快开始迫害小笼包吧！`;
                        }
                    };
                    
                    img.onerror = () => {
                        console.error(`无法加载图片: ${url}`);
                        dom.statusText.textContent = `错误: 无法加载图片 ${i+1}`;
                        
                        // 如果是网络图片失败，尝试不使用crossOrigin
                        if (url.startsWith('http') && img.crossOrigin) {
                            console.log('尝试不使用crossOrigin重新加载...');
                            img.crossOrigin = null;
                            img.src = url;
                        }
                    };
                    
                    anim.frameImages.push(img);
                }
            });
        }

        // 设置动画选择按钮
        function setupButtons() {
            const container = document.querySelector('.animation-buttons');
            container.innerHTML = '';
            
            config.buttons.forEach(btn => {
                const button = document.createElement('button');
                button.className = `anim-btn ${btn.id === state.currentAnimation ? 'active' : ''}`;
                button.dataset.anim = btn.id;
                button.textContent = btn.text;
                button.addEventListener('click', () => {
                    document.querySelector('.anim-btn.active').classList.remove('active');
                    button.classList.add('active');
                    changeAnimation(btn.id);
                });
                container.appendChild(button);
            });
        }

        // 设置速度控制
        function setupSpeedControl() {
            dom.speedSlider.addEventListener('input', (e) => {
                const speed = parseFloat(e.target.value);
                state.playSpeed = speed;
                
                // 更新显示
                const frameTime = Math.round(200 / speed);
                dom.speedDisplay.textContent = `${speed.toFixed(1)}x 速度 (${frameTime}ms/帧)`;
                
                // 如果正在播放，重新启动动画以应用新速度
                if (state.isPlaying) {
                    stopAnimation();
                    startAnimation();
                }
                
                console.log(`速度调整为: ${speed}x, 帧间隔: ${frameTime}ms`);
            });
        }


        // 设置事件监听器
        function setupEventListeners() {
            // 上传区域点击事件
            dom.uploadArea.addEventListener('click', () => dom.imageUpload.click());
            
            // 文件上传事件
            dom.imageUpload.addEventListener('change', handleImageUpload);
            
            // 测试按钮事件
            dom.testBtn.addEventListener('click', saveComposedImages);
            
            // 保存按钮事件
            dom.saveBtn.addEventListener('click', saveAsGif);
            
            // 允许拖放上传
            dom.uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dom.uploadArea.style.background = 'rgba(74, 134, 232, 0.3)';
            });
            
            dom.uploadArea.addEventListener('dragleave', () => {
                dom.uploadArea.style.background = 'rgba(74, 134, 232, 0.1)';
            });
            
            dom.uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dom.uploadArea.style.background = 'rgba(74, 134, 232, 0.1)';
                
                if (e.dataTransfer.files.length) {
                    dom.imageUpload.files = e.dataTransfer.files;
                    handleImageUpload();
                }
            });
        }

        // 处理图片上传
        function handleImageUpload() {
            const file = dom.imageUpload.files[0];
            if (!file) return;
            
            if (!file.type.match('image.*')) {
                dom.statusText.textContent = '请上传图片文件 (JPG, PNG)';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                state.userImage = new Image();
                state.userImage.src = e.target.result;
                state.userImage.onload = () => {
                    dom.statusText.textContent = '图片上传成功!';
                    
                    // 修复预览显示问题
                    const preview = dom.userImagePreview;
                    preview.src = state.userImage.src;
                    preview.style.display = 'block';
                    preview.onload = () => {
                        console.log('预览图片加载成功');
                    };
                    preview.onerror = () => {
                        console.error('预览图片加载失败');
                        preview.style.display = 'none';
                    };
                    
                    // 处理用户图片
                    console.log('开始处理用户图片');
                    processUserImage();
                    
                    // 清除缓存
                    state.composedFrames = {};
                };
            };
            reader.readAsDataURL(file);
        }

        // 更改当前动画
        function changeAnimation(animId) {
            stopAnimation();
            state.currentAnimation = animId;
            state.currentFrame = 0;
            dom.animName.textContent = config.animations[animId].name;
            
            // 重新处理用户图片（不同动画有不同处理方式）
            if (state.userImage) {
                console.log('切换动画，重新处理用户图片');
                processUserImage();
            } else {
                renderFrame(0);
            }
            
            dom.statusText.textContent = `已选择: ${config.animations[animId].name}`;
            
            // 自动开始播放新动画
            startAnimation();
        }

        // 渲染指定帧 - 使用配置的canvas尺寸
        function renderFrame(frameIndex) {
            const anim = config.animations[state.currentAnimation];
            const canvas = dom.canvas;
            const ctx = dom.ctx;
            
            // 使用配置的canvas尺寸
            const canvasWidth = anim.canvasSize ? anim.canvasSize.width : 800;
            const canvasHeight = anim.canvasSize ? anim.canvasSize.height : 450;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景图片
            if (anim.frameImages[frameIndex] && anim.frameImages[frameIndex].complete) {
                const img = anim.frameImages[frameIndex];
                
                // 将背景图片缩放到canvas尺寸
                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                
                console.log(`Canvas尺寸: ${canvasWidth}x${canvasHeight}, 背景图片: ${img.naturalWidth}x${img.naturalHeight}`);
            } else {
                // 如果图片未加载完成，显示占位背景
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`加载中: ${anim.name} 帧 ${frameIndex+1}`, canvas.width/2, canvas.height/2);
                
                console.log('背景图片未加载完成，使用配置尺寸');
            }
            
            // 绘制用户图片
            if (state.userImage && state.processedUserImage) {
                const pos = anim.overlayPositions[frameIndex];
                
                console.log(`绘制用户图片 - 帧${frameIndex}: 位置(${pos.x}, ${pos.y}), 旋转${pos.rotation}°, 缩放${pos.scale}`);
                
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.rotation * Math.PI / 180);
                
                // 绘制处理后的用户图片
                const imgWidth = state.processedUserImage.width * pos.scale;
                const imgHeight = state.processedUserImage.height * pos.scale;
                
                ctx.drawImage(
                    state.processedUserImage, 
                    -imgWidth/2, 
                    -imgHeight/2,
                    imgWidth,
                    imgHeight
                );
                
                ctx.restore();
                
                // 更新位置信息
                if (dom.framePositionInfo) {
                    dom.framePositionInfo.textContent = 
                        `当前帧位置: (${pos.x}, ${pos.y}) 旋转: ${pos.rotation}°`;
                }
            } else {
                console.log('用户图片未准备好:', !!state.userImage, !!state.processedUserImage);
            }
        }


        // 开始播放动画
        function startAnimation() {
            if (state.isPlaying) {
                return; // 如果已经在播放，不重复启动
            }
            
            const anim = config.animations[state.currentAnimation];
            state.isPlaying = true;
            
            // 计算播放间隔：基础200ms除以速度倍数
            const frameInterval = 200 / state.playSpeed;
            
            console.log(`开始播放动画: ${anim.name}, 帧数: ${anim.frameCount}, 速度: ${state.playSpeed}x, 间隔: ${frameInterval}ms`);
            
            state.frameInterval = setInterval(() => {
                state.currentFrame = (state.currentFrame + 1) % anim.frameCount;
                console.log(`切换到帧: ${state.currentFrame}`);
                renderFrame(state.currentFrame);
            }, frameInterval);
        }

        // 停止播放动画
        function stopAnimation() {
            if (state.frameInterval) {
                clearInterval(state.frameInterval);
                state.frameInterval = null;
            }
            state.isPlaying = false;
        }

        // 合成并保存图片到images文件夹用于测试
        async function saveComposedImages() {
            if (!state.userImage || !state.userImage.complete) {
                updateProgress('请先上传图片！');
                return;
            }
            
            const anim = config.animations[state.currentAnimation];
            const { width: canvasWidth, height: canvasHeight } = getBackgroundDimensions();
            
            try {
                for (let i = 0; i < anim.frameCount; i++) {
                    updateProgress(`正在合成第 ${i + 1}/${anim.frameCount} 帧...`);
                    
                    // 使用公共的帧合成函数
                    const compositeCanvas = await createCompositeFrame(i, canvasWidth, canvasHeight);
                    
                    // 转换为blob并下载
                    const blob = await new Promise(resolve => {
                        compositeCanvas.toBlob(resolve, 'image/png', 1.0);
                    });
                    
                    const fileName = `composed_frame_${i}.png`;
                    downloadImage(blob, fileName);
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                updateProgress('合成图片保存完成！');
            } catch (error) {
                console.error('合成图片失败:', error);
                updateProgress('合成图片失败');
            }
        }
        
        // 通用下载函数
        function downloadFile(blob, fileName, fileType = 'image/png') {
            try {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                return true;
            } catch (error) {
                console.error(`下载${fileType}失败:`, error);
                return false;
            }
        }
        
        // 下载单张图片
        function downloadImage(blob, fileName) {
            return downloadFile(blob, fileName, 'PNG图片');
        }
        
        // 获取canvas尺寸的通用函数
        function getBackgroundDimensions(animationId) {
            const anim = config.animations[animationId || state.currentAnimation];
            
            // 优先使用配置的canvas尺寸
            if (anim.canvasSize) {
                return { width: anim.canvasSize.width, height: anim.canvasSize.height };
            }
            
            // 备用：使用背景图片原始尺寸
            if (anim.frameImages[0] && anim.frameImages[0].complete) {
                return { width: anim.frameImages[0].naturalWidth, height: anim.frameImages[0].naturalHeight };
            }
            
            // 默认尺寸
            return { width: 800, height: 450 };
        }
        
        // 更新状态文本和进度的通用函数
        function updateProgress(text, progress = null) {
            dom.statusText.textContent = text;
            if (progress !== null) {
                dom.progressBar.style.width = `${progress}%`;
            }
        }
        
        // 使用gifshot库导出GIF
        async function saveAsGif() {
            if (!state.userImage || !state.userImage.complete) {
                updateProgress('请先上传图片！');
                return;
            }
            
            updateProgress('正在生成GIF...', 0);
            dom.saveBtn.disabled = true;
            dom.testBtn.disabled = true;
            dom.progressContainer.style.display = 'block';
            
            try {
                const anim = config.animations[state.currentAnimation];
                const { width: canvasWidth, height: canvasHeight } = getBackgroundDimensions();
                
                // 生成所有帧的canvas数组
                const frameCanvases = [];
                for (let i = 0; i < anim.frameCount; i++) {
                    updateProgress(`正在处理第 ${i + 1}/${anim.frameCount} 帧...`, ((i + 1) / anim.frameCount) * 20);
                    const frameCanvas = await createCompositeFrame(i, canvasWidth, canvasHeight);
                    frameCanvases.push(frameCanvas);
                    await new Promise(resolve => setTimeout(resolve, 30));
                }
                
                console.log(`准备生成GIF: ${frameCanvases.length}帧, 尺寸: ${canvasWidth}x${canvasHeight}`);
                
                // 检查并使用gifshot库
                if (typeof gifshot !== 'undefined' && gifshot && gifshot.createGIF) {
                    await saveWithGifshot(frameCanvases, anim, canvasWidth, canvasHeight);
                } else {
                    console.warn('gifshot库未加载，尝试动态加载...');
                    updateProgress('正在加载GIF导出库...', 25);
                    
                    const gifshotLoaded = await loadGifshotLibrary();
                    if (gifshotLoaded) {
                        await saveWithGifshot(frameCanvases, anim, canvasWidth, canvasHeight);
                    } else {
                        updateProgress('GIF导出库加载失败，请检查网络连接');
                        resetSaveButton();
                    }
                }
                
            } catch (error) {
                console.error('GIF生成失败:', error);
                updateProgress(`GIF生成失败: ${error.message}`);
                resetSaveButton();
            }
        }
        
        // 使用gifshot库进行最高质量导出
        async function saveWithGifshot(frameCanvases, anim, canvasWidth, canvasHeight) {
            updateProgress('正在使用gifshot库生成最高质量GIF...', 30);
            
            try {
                // 将canvas转换为图片数组
                const frameImages = [];
                for (let i = 0; i < frameCanvases.length; i++) {
                    updateProgress(`转换第 ${i + 1}/${frameCanvases.length} 帧...`, 30 + ((i + 1) / frameCanvases.length) * 20);
                    
                    const dataURL = frameCanvases[i].toDataURL('image/png', 1.0);
                    frameImages.push(dataURL);
                    
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
                
                updateProgress('正在生成最高质量GIF文件...', 60);
                
                const frameDelay = Math.round(200 / state.playSpeed) / 1000; // gifshot使用秒为单位
                
                // gifshot高质量配置
                const gifshotOptions = {
                    images: frameImages,
                    gifWidth: canvasWidth,
                    gifHeight: canvasHeight,
                    interval: frameDelay,
                    numFrames: frameCanvases.length,
                    frameDuration: frameDelay,
                    sampleInterval: 1, // 最高质量采样
                    numWorkers: Math.min(navigator.hardwareConcurrency || 2, 4),
                    quality: 'high', // 高质量
                    repeat: 0, // 无限循环
                    progressCallback: function(captureProgress) {
                        const progress = 60 + (captureProgress * 35);
                        updateProgress(`生成中... ${Math.round(progress)}%`, progress);
                    }
                };
                
                console.log('gifshot配置:', gifshotOptions);
                
                // 使用gifshot生成GIF
                gifshot.createGIF(gifshotOptions, function(obj) {
                    if (!obj.error) {
                        const gifBlob = dataURLToBlob(obj.image);
                        const fileName = `${anim.name.replace(/\s+/g, '_')}_动画_${state.playSpeed}x速度.gif`;
                        
                        console.log(`GIF生成成功: ${(gifBlob.size/1024).toFixed(1)}KB`);
                        
                        const success = downloadFile(gifBlob, fileName, 'GIF动画');
                        
                        if (success) {
                            updateProgress('GIF保存成功！', 100);
                            console.log(`GIF下载成功: ${fileName}, 大小: ${(gifBlob.size / 1024 / 1024).toFixed(2)}MB`);
                        } else {
                            updateProgress('下载失败，请重试');
                        }
                        
                        setTimeout(resetSaveButton, 2000);
                    } else {
                        console.error('GIF生成失败:', obj.error);
                        updateProgress('GIF生成失败: ' + obj.error);
                        resetSaveButton();
                    }
                });
                
            } catch (error) {
                console.error('gifshot处理失败:', error);
                updateProgress('GIF生成失败: ' + error.message);
                resetSaveButton();
            }
        }
        
        
        
        // 动态加载gifshot库
        function loadGifshotLibrary() {
            return new Promise((resolve) => {
                // 如果已经加载，直接返回
                if (typeof gifshot !== 'undefined' && gifshot && gifshot.createGIF) {
                    resolve(true);
                    return;
                }
                
                console.log('尝试动态加载gifshot库...');
                
                // 创建script标签动态加载
                const script = document.createElement('script');
                script.src = 'https://cdn.jsdelivr.net/npm/gifshot@0.4.5/dist/gifshot.min.js';
                script.crossOrigin = 'anonymous';
                
                script.onload = () => {
                    console.log('gifshot库动态加载成功');
                    // 等待一小段时间确保库完全初始化
                    setTimeout(() => {
                        if (typeof gifshot !== 'undefined' && gifshot && gifshot.createGIF) {
                            resolve(true);
                        } else {
                            console.error('gifshot库加载后仍不可用');
                            resolve(false);
                        }
                    }, 100);
                };
                
                script.onerror = () => {
                    console.error('gifshot库动态加载失败');
                    resolve(false);
                };
                
                document.head.appendChild(script);
                
                // 设置超时
                setTimeout(() => {
                    console.error('gifshot库加载超时');
                    resolve(false);
                }, 5000);
            });
        }
        
        // 将DataURL转换为Blob
        function dataURLToBlob(dataURL) {
            const byteString = atob(dataURL.split(',')[1]);
            const mimeString = dataURL.split(',')[0].split(':')[1].split(';')[0];
            const ab = new ArrayBuffer(byteString.length);
            const ia = new Uint8Array(ab);
            for (let i = 0; i < byteString.length; i++) {
                ia[i] = byteString.charCodeAt(i);
            }
            return new Blob([ab], { type: mimeString });
        }
        
        // 创建合成帧
        async function createCompositeFrame(frameIndex, canvasWidth, canvasHeight) {
            const anim = config.animations[state.currentAnimation];
            
            // 创建离屏canvas
            const compositeCanvas = document.createElement('canvas');
            compositeCanvas.width = canvasWidth;
            compositeCanvas.height = canvasHeight;
            const ctx = compositeCanvas.getContext('2d', { 
                alpha: false,
                willReadFrequently: false
            });
            
            // 清空画布并设置黑色背景
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            
            // 启用高质量渲染
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            
            // 绘制背景图片
            if (anim.frameImages[frameIndex] && anim.frameImages[frameIndex].complete) {
                ctx.drawImage(anim.frameImages[frameIndex], 0, 0, canvasWidth, canvasHeight);
            }
            
            // 绘制用户图片
            if (state.processedUserImage && state.processedUserImage.complete) {
                const pos = anim.overlayPositions[frameIndex];
                
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.rotation * Math.PI / 180);
                
                const imgWidth = state.processedUserImage.width * pos.scale;
                const imgHeight = state.processedUserImage.height * pos.scale;
                
                ctx.drawImage(
                    state.processedUserImage,
                    -imgWidth/2,
                    -imgHeight/2,
                    imgWidth,
                    imgHeight
                );
                
                ctx.restore();
            }
            
            return compositeCanvas;
        }
        
        
        
        // 重置保存按钮状态
        function resetSaveButton() {
            dom.saveBtn.disabled = false;
            dom.testBtn.disabled = false; // 重新启用测试按钮
            dom.progressContainer.style.display = 'none';
            dom.progressBar.style.width = '0%';
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>