<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>动态图组合成工具</title>
    <!-- 引入gif.js库 -->
    <script src="gif.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            background-size: 400% 400%;
            animation: gradientBG 20s ease infinite;
            height: 100vh;
            position: relative;
            color: white;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        @keyframes gradientBG {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .background-text {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            overflow: hidden;
            pointer-events: none;
            user-select: none;
        }
        
        .background-text::before {
            content: "小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧 小笼包真浅草吧";
            position: absolute;
            top: -145%;
            left: -20%;
            width: 300%;
            height: 300%;
            font-size: 6vw;
            font-weight: 900;
            color: rgba(255, 255, 255, 0.1);
            transform: rotate(-30deg);
            line-height: 2;
            word-spacing: 2em;
            white-space: pre-wrap;
            overflow: hidden;
        }

        .container {
            display: flex;
            width: 95vw;
            height: 90vh;
            max-width: 1400px;
            background: rgba(0, 0, 0, 0.4);
            border-radius: 20px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(7px);
        }

        .preview-area {
            flex: 3;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 30px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        .preview-canvas {
            max-width: 100%;
            max-height: 100%;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background: #000;
            width: auto;
            height: auto;
            object-fit: contain; /* 确保不同尺寸图片都能正确显示 */
        }

        .control-panel {
            flex: 2;
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
            height: 100%;
        }
        
        /* 自定义滚动条样式 */
        .control-panel::-webkit-scrollbar {
            width: 8px;
        }
        
        .control-panel::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        .control-panel::-webkit-scrollbar-thumb {
            background: linear-gradient(to bottom, #6a11cb, #2575fc);
            border-radius: 4px;
        }
        
        .control-panel::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(to bottom, #ff416c, #ff4b2b);
        }

        .panel-title {
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #96ceb4, #ffc107, #e056fd);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: gradientShift 3s ease-in-out infinite;
            text-shadow: 0 0 20px rgba(255, 107, 107, 0.5), 
                         0 0 30px rgba(78, 205, 196, 0.3), 
                         0 0 40px rgba(69, 183, 209, 0.2);
            filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.3));
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        @keyframes gradientShift {
            0%, 100% {
                background-position: 0% 50%;
            }
            50% {
                background-position: 100% 50%;
            }
        }

        .animation-selector {
            background: rgba(30, 30, 50, 0.8);
            padding: 20px;
            border-radius: 15px;
        }

        .animation-buttons {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 15px;
        }

        .anim-btn {
            padding: 12px 15px;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(37, 117, 252, 0.3);
        }

        .anim-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(37, 117, 252, 0.5);
        }

        .anim-btn.active {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            box-shadow: 0 0 20px rgba(255, 65, 108, 0.6);
        }

        .upload-section {
            background: rgba(30, 30, 50, 0.8);
            padding: 20px;
            border-radius: 15px;
        }

        .upload-area {
            border: 3px dashed #4a86e8;
            border-radius: 10px;
            padding: 8px;
            text-align: center;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s;
            background: rgba(74, 134, 232, 0.1);
            max-width: 400px;
            margin: 20px auto;
        }

        .upload-area:hover {
            background: rgba(74, 134, 232, 0.2);
        }

        .upload-icon {
            font-size: 24px;
            margin-bottom: 5px;
            color: #4a86e8;
        }
        
        .upload-area p {
            margin: 3px 0;
            font-size: 14px;
        }
        
        .upload-area p.small {
            font-size: 12px;
            color: #aaa;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin-top: 20px;
        }

        .action-btn {
            flex: 1;
            padding: 15px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .play-btn {
            background: linear-gradient(to right, #00b09b, #96c93d);
            color: white;
        }

        .save-btn {
            background: linear-gradient(to right, #ff416c, #ff4b2b);
            color: white;
        }

        .action-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .status-text {
            text-align: center;
            margin-top: 15px;
            font-size: 14px;
            color: #aaa;
            min-height: 20px;
        }

        .preview-title {
            position: absolute;
            top: 20px;
            left: 20px;
            font-size: 18px;
            color: #ffcc00;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
        }
        
        .user-image-preview {
            max-width: 100px;
            max-height: 100px;
            border: 2px solid #4a86e8;
            border-radius: 8px;
            margin: 15px auto;
            display: none;
        }
        
        .position-info {
            background: rgba(30, 30, 50, 0.8);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 14px;
            text-align: center;
        }

        /* 响应式设计 */
        @media (max-width: 1200px) {
            .container {
                width: 98vw;
                height: 95vh;
            }
        }

        @media (max-width: 900px) {
            .container {
                flex-direction: column;
                width: 98vw;
                height: 95vh;
            }
            
            .preview-area {
                flex: 1;
                height: 40%;
                border-right: none;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
            
            .control-panel {
                flex: 1;
                height: 60%;
                padding: 20px;
            }
            
            .animation-buttons {
                grid-template-columns: repeat(3, 1fr);
                gap: 8px;
            }
            
            .anim-btn {
                padding: 10px 8px;
                font-size: 12px;
            }
        }

        @media (max-width: 600px) {
            .container {
                width: 99vw;
                height: 98vh;
                border-radius: 15px;
            }
            
            .preview-area {
                height: 35%;
                padding: 15px;
            }
            
            .control-panel {
                height: 65%;
                padding: 15px;
                gap: 15px;
            }
            
            .panel-title {
                font-size: 22px;
            }
            
            .animation-buttons {
                grid-template-columns: repeat(2, 1fr);
                gap: 6px;
            }
            
            .anim-btn {
                padding: 12px 8px;
                font-size: 11px;
                min-height: 44px; /* 触摸友好的最小高度 */
            }
            
            .speed-slider {
                height: 10px;
            }
            
            .speed-slider::-webkit-slider-thumb {
                width: 18px;
                height: 18px;
            }
            
            .speed-slider::-moz-range-thumb {
                width: 18px;
                height: 18px;
            }
        }

        @media (max-width: 400px) {
            .animation-buttons {
                grid-template-columns: 1fr;
            }
            
            .preview-area {
                height: 30%;
            }
            
            .control-panel {
                height: 70%;
            }
            
            .panel-title {
                font-size: 18px;
            }
        }
        
        /* 新增进度条样式 */
        .progress-container {
            width: 100%;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
            margin-top: 10px;
            overflow: hidden;
            display: none;
        }
        
        .progress-bar {
            height: 100%;
            background: linear-gradient(to right, #00b09b, #96c93d);
            width: 0%;
            transition: width 0.3s;
        }
        
        /* 速度控制滑条样式 */
        .speed-control {
            background: rgba(30, 30, 50, 0.8);
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 15px;
        }
        
        .speed-slider {
            width: 100%;
            height: 8px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            margin: 10px 0;
            -webkit-appearance: none;
            appearance: none;
        }
        
        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .speed-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(to right, #6a11cb, #2575fc);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
        }
        
        .speed-info {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #aaa;
            margin-top: 5px;
        }
        
        .speed-display {
            text-align: center;
            color: #ffcc00;
            font-weight: bold;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <div class="background-text"></div>
    
    <div class="container">
        <div class="preview-area">
            <div class="preview-title">预览区域 - <span id="animName">玩法1</span></div>
            <canvas id="previewCanvas" class="preview-canvas" width="800" height="450"></canvas>
        </div>
        
        <div class="control-panel">
            <h2 class="panel-title">小笼包的玩法大全</h2>
            
            <div class="animation-selector">
                <h3>💗选择玩法💗</h3>
                <div class="animation-buttons" id="animationButtons">
                    <!-- 按钮将通过JavaScript动态生成 -->
                </div>
                
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">🤴</div>
                    <p>点击或拖放</p>
                    <p class="small">小笼包主人照片</p>
                </div>
                <img id="userImagePreview" class="user-image-preview" alt="用户上传的图片">
                <input type="file" id="imageUpload" accept="image/*" style="display: none;">
                <!--<div class="position-info">
                    <p id="framePositionInfo">当前帧位置: (400, 225) 旋转: 0°</p>
                </div>-->
            </div>
            
            <div class="speed-control">
                <h3>慢玩or冲刺</h3>
                
                <div class="speed-display" id="speedDisplay" style="margin-top: 15px;">1.0x 速度 (200ms/帧)</div>
                <input type="range" class="speed-slider" id="speedSlider" 
                       min="0.1" max="10" step="0.1" value="1">
                <div class="speed-info">
                    <span>0.1x (慢)</span>
                    <span>10x (快)</span>
                </div>
                
                <div class="speed-display" id="qualityDisplay" style="margin-top: 15px;">最高品质 (无噪点)</div>
                <input type="range" class="speed-slider" id="qualitySlider" 
                       min="1" max="30" step="1" value="1">
                <div class="speed-info">
                    <span>最低品质</span>
                    <span>最高品质</span>
                </div>
                
                <div class="speed-display" style="margin-top: 15px;">抖动算法: <span id="ditherDisplay">Atkinson-serpentine</span></div>
                <select class="speed-slider" id="ditherSelect" style="width: 100%; padding: 8px; border-radius: 4px; background: rgba(255,255,255,0.1); color: white; border: 1px solid rgba(255,255,255,0.3);">
                    <option value="false">无抖动 (可能有色带)</option>
                    <option value="FloydSteinberg">Floyd-Steinberg</option>
                    <option value="FloydSteinberg-serpentine">Floyd-Steinberg 蛇形</option>
                    <option value="Atkinson" selected>Atkinson (推荐)</option>
                    <option value="Atkinson-serpentine">Atkinson 蛇形 (默认)</option>
                    <option value="Stucki">Stucki</option>
                    <option value="Stucki-serpentine">Stucki 蛇形</option>
                    <option value="FalseFloydSteinberg">False Floyd-Steinberg</option>
                </select>
            </div>
            
            <div class="action-buttons" style="margin-top: 5px;">
                <button class="action-btn play-btn" id="testBtn">测试合成图片</button>
                <button class="action-btn save-btn" id="saveBtn">保存为GIF</button>
            </div>
            
            <div class="status-text" id="statusText">准备好创建您的动画！</div>
            <!-- 新增进度条 -->
            <div class="progress-container" id="progressContainer">
                <div class="progress-bar" id="progressBar"></div>
            </div>
        </div>
    </div>

    <script>
        // 配置信息
        const config = {
            // 按钮配置（可轻松添加/删除/修改）
            buttons: [
                { id: "1", text: "玩法1" },
                { id: "2", text: "玩法2" },
                { id: "3", text: "玩法3" },
                { id: "4", text: "玩法4" },
                { id: "5", text: "玩法5" },
                { id: "6", text: "玩法6" },
                { id: "7", text: "玩法7" },
                { id: "8", text: "玩法8" },
                { id: "9", text: "玩法9" },
                { id: "10", text: "玩法10" }
            ],
            
            // 动画帧配置
            // 每个玩法可以设置：
            // - canvasSize: { width: 宽度, height: 高度 } - 设置导出GIF的尺寸
            // - overlayPositions: 用户图片在每帧中的位置、旋转、缩放
            animations: {
                "1": {
                    name: "玩法1",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                        'image1/frame0.png',
                        'image1/frame1.png'
                    ],
                    // Canvas尺寸配置（可修改）
                    canvasSize: { width: 180, height: 140 },
                    // 每帧的叠加位置和旋转参数
                    overlayPositions: [
                        { x: 115, y: 55, rotation: 0, scale: 1 },
                        { x: 105, y: 50, rotation: 0, scale: 1 }
                    ]
                },
                "2": {
                    name: "玩法2",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 180, height: 140 },
                    overlayPositions: [
                        { x: 400, y: 180, rotation: 0, scale: 0.4 },
                        { x: 400, y: 200, rotation: 0, scale: 0.46 }
                    ]
                },
                "3": {
                    name: "玩法3",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 180, height: 140 },
                    overlayPositions: [
                        { x: 400, y: 200, rotation: 0, scale: 0.6 },
                        { x: 350, y: 200, rotation: 348, scale: 0.6 }
                    ]
                },
                "4": {
                    name: "玩法4",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 400, y: 280, rotation: 0, scale: 0.8 },
                        { x: 400, y: 140, rotation: 0, scale: 0.8 }
                    ]
                },
                "5": {
                    name: "玩法5",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 350, y: 200, rotation: -30, scale: 0.7 },
                        { x: 450, y: 200, rotation: 30, scale: 0.7 }
                    ]
                },
                "6": {
                    name: "玩法6",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 400, y: 200, rotation: 0, scale: 1.2 },
                        { x: 400, y: 200, rotation: 0, scale: 0.6 }
                    ]
                },
                "7": {
                    name: "玩法7",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 380, y: 180, rotation: 15, scale: 0.9 },
                        { x: 420, y: 220, rotation: -15, scale: 0.9 }
                    ]
                },
                "8": {
                    name: "玩法8",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 400, y: 200, rotation: 0, scale: 0.5 },
                        { x: 400, y: 200, rotation: 0, scale: 1.5 }
                    ]
                },
                "9": {
                    name: "玩法9",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 450, y: 160, rotation: 90, scale: 0.8 },
                        { x: 350, y: 240, rotation: 270, scale: 0.8 }
                    ]
                },
                "10": {
                    name: "玩法10",
                    frameCount: 2,
                    frameImages: [],
                    frameURLs: [
                       'image1/frame0.png',
                       'image1/frame1.png'
                    ],
                    canvasSize: { width: 800, height: 450 },
                    overlayPositions: [
                        { x: 395, y: 200, rotation: -5, scale: 1.0 },
                        { x: 405, y: 210, rotation: 5, scale: 1.0 }
                    ]
                }
            }
        };

        // DOM 元素
        const dom = {
            canvas: document.getElementById('previewCanvas'),
            ctx: document.getElementById('previewCanvas').getContext('2d'),
            uploadArea: document.getElementById('uploadArea'),
            imageUpload: document.getElementById('imageUpload'),
            userImagePreview: document.getElementById('userImagePreview'),
            testBtn: document.getElementById('testBtn'),
            saveBtn: document.getElementById('saveBtn'),
            statusText: document.getElementById('statusText'),
            animName: document.getElementById('animName'),
            framePositionInfo: document.getElementById('framePositionInfo'),
            progressContainer: document.getElementById('progressContainer'),
            progressBar: document.getElementById('progressBar'),
            speedSlider: document.getElementById('speedSlider'),
            speedDisplay: document.getElementById('speedDisplay')
        };

        // 应用状态
        const state = {
            currentAnimation: '1',
            userImage: null,
            processedUserImage: null,
            isPlaying: false,
            currentFrame: 0,
            frameInterval: null,
            composedFrames: {},
            playSpeed: 1.0, // 播放速度倍数，1.0 = 200ms/帧
            gifQuality: 1, // GIF品质 (1-30, 数字越小品质越高)
            ditherMethod: 'Atkinson-serpentine', // 抖动算法
            gif: null // gif.js实例
        };

        // 初始化函数
        function init() {
            // 添加这一行解决跨域问题
            dom.ctx = dom.canvas.getContext('2d', { willReadFrequently: true });
            
            // 初始化gif.js
            console.log('初始化gif.js库...');
            
            if (typeof GIF !== 'undefined') {
                console.log('✓ gif.js库加载成功');
            } else {
                console.error('✗ gif.js库加载失败');
            }
            
            setupButtons();
            setupEventListeners();
            setupSpeedControl();
            setupQualityControl();
            setupDitherControl();
            preloadFrameImages();
            renderFrame(0);
            // 自动开始播放动画
            startAnimation();
        }

        // 新增函数：处理用户图片
        function processUserImage() {
            if (!state.userImage) return;
            
            const anim = config.animations[state.currentAnimation];
            
            // 根据不同动画效果处理图片
            switch(state.currentAnimation) {
                case '1': // 旋转地球 - 处理为85像素直径的圆形
                    createCircularImage(state.userImage, 85).then(processedImg => {
                        state.processedUserImage = processedImg;
                        console.log('圆形图片处理完成');
                        renderFrame(state.currentFrame);
                    });
                    break;
                case '2': // 跳动心形 - 保持原样（可以后续扩展）
                case '3': // 旋转立方体 - 保持原样（可以后续扩展）
                default:
                    state.processedUserImage = state.userImage;
                    console.log('用户图片处理完成');
                    renderFrame(state.currentFrame);
                    break;
            }
        }

        // 新增函数：创建圆形图片
        function createCircularImage(sourceImage, diameter) {
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = diameter;
                canvas.height = diameter;
                
                // 计算缩放比例
                const sourceWidth = sourceImage.width;
                const sourceHeight = sourceImage.height;
                const minSide = Math.min(sourceWidth, sourceHeight);
                const scale = diameter / minSide;
                
                // 计算缩放后的尺寸
                const scaledWidth = sourceWidth * scale;
                const scaledHeight = sourceHeight * scale;
                
                // 计算居中位置
                const offsetX = (diameter - scaledWidth) / 2;
                const offsetY = (diameter - scaledHeight) / 2;
                
                // 创建圆形裁剪路径
                ctx.beginPath();
                ctx.arc(diameter / 2, diameter / 2, diameter / 2, 0, Math.PI * 2);
                ctx.clip();
                
                // 绘制缩放后的图片
                ctx.drawImage(sourceImage, offsetX, offsetY, scaledWidth, scaledHeight);
                
                // 创建新的Image对象返回
                const processedImage = new Image();
                processedImage.onload = () => resolve(processedImage);
                processedImage.src = canvas.toDataURL();
            });
        }

        // 修改preloadFrameImages函数，改进跨域处理
        function preloadFrameImages() {
            Object.keys(config.animations).forEach(animId => {
                const anim = config.animations[animId];
                anim.frameImages = [];
                
                for (let i = 0; i < anim.frameCount; i++) {
                    const img = new Image();
                    const url = anim.frameURLs[i];
                    
                    // 改进的跨域处理
                    if (url.startsWith('http')) {
                        img.crossOrigin = "anonymous";
                        img.src = url;
                    } else {
                        // 本地资源
                        img.src = url;
                    }
                    
                    img.onload = () => {
                        console.log(`图片加载成功: ${url}`);
                        dom.statusText.textContent = `加载中: ${anim.name} (${i+1}/${anim.frameCount})`;
                        if (i === anim.frameCount - 1) {
                            dom.statusText.textContent = `快开始迫害小笼包吧！`;
                        }
                    };
                    
                    img.onerror = () => {
                        console.error(`无法加载图片: ${url}`);
                        dom.statusText.textContent = `错误: 无法加载图片 ${i+1}`;
                        
                        // 如果是网络图片失败，尝试不使用crossOrigin
                        if (url.startsWith('http') && img.crossOrigin) {
                            console.log('尝试不使用crossOrigin重新加载...');
                            img.crossOrigin = null;
                            img.src = url;
                        }
                    };
                    
                    anim.frameImages.push(img);
                }
            });
        }

        // 设置动画选择按钮
        function setupButtons() {
            const container = document.querySelector('.animation-buttons');
            container.innerHTML = '';
            
            config.buttons.forEach(btn => {
                const button = document.createElement('button');
                button.className = `anim-btn ${btn.id === state.currentAnimation ? 'active' : ''}`;
                button.dataset.anim = btn.id;
                button.textContent = btn.text;
                button.addEventListener('click', () => {
                    document.querySelector('.anim-btn.active').classList.remove('active');
                    button.classList.add('active');
                    changeAnimation(btn.id);
                });
                container.appendChild(button);
            });
        }

        // 设置速度控制
        function setupSpeedControl() {
            dom.speedSlider.addEventListener('input', (e) => {
                const speed = parseFloat(e.target.value);
                state.playSpeed = speed;
                
                // 更新显示
                const frameTime = Math.round(200 / speed);
                dom.speedDisplay.textContent = `${speed.toFixed(1)}x 速度 (${frameTime}ms/帧)`;
                
                // 如果正在播放，重新启动动画以应用新速度
                if (state.isPlaying) {
                    stopAnimation();
                    startAnimation();
                }
                
                console.log(`速度调整为: ${speed}x, 帧间隔: ${frameTime}ms`);
            });
        }

        // 设置品质控制
        function setupQualityControl() {
            const qualitySlider = document.getElementById('qualitySlider');
            const qualityDisplay = document.getElementById('qualityDisplay');
            
            qualitySlider.addEventListener('input', (e) => {
                const quality = parseInt(e.target.value);
                state.gifQuality = quality;
                
                // 更新显示
                let qualityText;
                if (quality <= 3) {
                    qualityText = '最高品质';
                } else if (quality <= 10) {
                    qualityText = '高品质';
                } else if (quality <= 20) {
                    qualityText = '中品质';
                } else {
                    qualityText = '低品质';
                }
                
                qualityDisplay.textContent = `${qualityText} (品质值: ${quality})`;
                
                console.log(`GIF品质调整为: ${quality}, 描述: ${qualityText}`);
            });
            
            // 初始化显示
            const initialQuality = parseInt(qualitySlider.value);
            state.gifQuality = initialQuality;
            qualityDisplay.textContent = '最高品质 (品质值: ' + initialQuality + ')';
        }
        
        // 设置抖动算法控制
        function setupDitherControl() {
            const ditherSelect = document.getElementById('ditherSelect');
            const ditherDisplay = document.getElementById('ditherDisplay');
            
            ditherSelect.addEventListener('change', (e) => {
                const method = e.target.value;
                state.ditherMethod = method === 'false' ? false : method;
                
                ditherDisplay.textContent = method === 'false' ? '无抖动' : method;
                
                console.log(`抖动算法调整为: ${method}`);
            });
            
            // 初始化显示
            state.ditherMethod = ditherSelect.value;
            ditherDisplay.textContent = ditherSelect.value;
        }

        // 设置事件监听器
        function setupEventListeners() {
            // 上传区域点击事件
            dom.uploadArea.addEventListener('click', () => dom.imageUpload.click());
            
            // 文件上传事件
            dom.imageUpload.addEventListener('change', handleImageUpload);
            
            // 测试按钮事件
            dom.testBtn.addEventListener('click', saveComposedImages);
            
            // 保存按钮事件
            dom.saveBtn.addEventListener('click', saveAsGif);
            
            // 允许拖放上传
            dom.uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dom.uploadArea.style.background = 'rgba(74, 134, 232, 0.3)';
            });
            
            dom.uploadArea.addEventListener('dragleave', () => {
                dom.uploadArea.style.background = 'rgba(74, 134, 232, 0.1)';
            });
            
            dom.uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dom.uploadArea.style.background = 'rgba(74, 134, 232, 0.1)';
                
                if (e.dataTransfer.files.length) {
                    dom.imageUpload.files = e.dataTransfer.files;
                    handleImageUpload();
                }
            });
        }

        // 处理图片上传
        function handleImageUpload() {
            const file = dom.imageUpload.files[0];
            if (!file) return;
            
            if (!file.type.match('image.*')) {
                dom.statusText.textContent = '请上传图片文件 (JPG, PNG)';
                return;
            }
            
            const reader = new FileReader();
            reader.onload = (e) => {
                state.userImage = new Image();
                state.userImage.src = e.target.result;
                state.userImage.onload = () => {
                    dom.statusText.textContent = '图片上传成功!';
                    
                    // 修复预览显示问题
                    const preview = dom.userImagePreview;
                    preview.src = state.userImage.src;
                    preview.style.display = 'block';
                    preview.onload = () => {
                        console.log('预览图片加载成功');
                    };
                    preview.onerror = () => {
                        console.error('预览图片加载失败');
                        preview.style.display = 'none';
                    };
                    
                    // 处理用户图片
                    console.log('开始处理用户图片');
                    processUserImage();
                    
                    // 清除缓存
                    state.composedFrames = {};
                };
            };
            reader.readAsDataURL(file);
        }

        // 更改当前动画
        function changeAnimation(animId) {
            stopAnimation();
            state.currentAnimation = animId;
            state.currentFrame = 0;
            dom.animName.textContent = config.animations[animId].name;
            
            // 重新处理用户图片（不同动画有不同处理方式）
            if (state.userImage) {
                console.log('切换动画，重新处理用户图片');
                processUserImage();
            } else {
                renderFrame(0);
            }
            
            dom.statusText.textContent = `已选择: ${config.animations[animId].name}`;
            
            // 自动开始播放新动画
            startAnimation();
        }

        // 渲染指定帧 - 使用配置的canvas尺寸
        function renderFrame(frameIndex) {
            const anim = config.animations[state.currentAnimation];
            const canvas = dom.canvas;
            const ctx = dom.ctx;
            
            // 使用配置的canvas尺寸
            const canvasWidth = anim.canvasSize ? anim.canvasSize.width : 800;
            const canvasHeight = anim.canvasSize ? anim.canvasSize.height : 450;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            
            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 绘制背景图片
            if (anim.frameImages[frameIndex] && anim.frameImages[frameIndex].complete) {
                const img = anim.frameImages[frameIndex];
                
                // 将背景图片缩放到canvas尺寸
                ctx.drawImage(img, 0, 0, canvasWidth, canvasHeight);
                
                console.log(`Canvas尺寸: ${canvasWidth}x${canvasHeight}, 背景图片: ${img.naturalWidth}x${img.naturalHeight}`);
            } else {
                // 如果图片未加载完成，显示占位背景
                ctx.fillStyle = '#222';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`加载中: ${anim.name} 帧 ${frameIndex+1}`, canvas.width/2, canvas.height/2);
                
                console.log('背景图片未加载完成，使用配置尺寸');
            }
            
            // 绘制用户图片
            if (state.userImage && state.processedUserImage) {
                const pos = anim.overlayPositions[frameIndex];
                
                console.log(`绘制用户图片 - 帧${frameIndex}: 位置(${pos.x}, ${pos.y}), 旋转${pos.rotation}°, 缩放${pos.scale}`);
                
                ctx.save();
                ctx.translate(pos.x, pos.y);
                ctx.rotate(pos.rotation * Math.PI / 180);
                
                // 绘制处理后的用户图片
                const imgWidth = state.processedUserImage.width * pos.scale;
                const imgHeight = state.processedUserImage.height * pos.scale;
                
                ctx.drawImage(
                    state.processedUserImage, 
                    -imgWidth/2, 
                    -imgHeight/2,
                    imgWidth,
                    imgHeight
                );
                
                ctx.restore();
                
                // 更新位置信息
                if (dom.framePositionInfo) {
                    dom.framePositionInfo.textContent = 
                        `当前帧位置: (${pos.x}, ${pos.y}) 旋转: ${pos.rotation}°`;
                }
            } else {
                console.log('用户图片未准备好:', !!state.userImage, !!state.processedUserImage);
            }
        }


        // 开始播放动画
        function startAnimation() {
            if (state.isPlaying) {
                return; // 如果已经在播放，不重复启动
            }
            
            const anim = config.animations[state.currentAnimation];
            state.isPlaying = true;
            
            // 计算播放间隔：基础200ms除以速度倍数
            const frameInterval = 200 / state.playSpeed;
            
            console.log(`开始播放动画: ${anim.name}, 帧数: ${anim.frameCount}, 速度: ${state.playSpeed}x, 间隔: ${frameInterval}ms`);
            
            state.frameInterval = setInterval(() => {
                state.currentFrame = (state.currentFrame + 1) % anim.frameCount;
                console.log(`切换到帧: ${state.currentFrame}`);
                renderFrame(state.currentFrame);
            }, frameInterval);
        }

        // 停止播放动画
        function stopAnimation() {
            if (state.frameInterval) {
                clearInterval(state.frameInterval);
                state.frameInterval = null;
            }
            state.isPlaying = false;
        }

        // 合成并保存图片到images文件夹用于测试
        async function saveComposedImages() {
            if (!state.userImage || !state.userImage.complete) {
                updateProgress('请先上传图片！');
                return;
            }
            
            const anim = config.animations[state.currentAnimation];
            const { width: canvasWidth, height: canvasHeight } = getBackgroundDimensions();
            
            try {
                for (let i = 0; i < anim.frameCount; i++) {
                    updateProgress(`正在合成第 ${i + 1}/${anim.frameCount} 帧...`);
                    
                    // 使用公共的帧合成函数
                    const compositeCanvas = await createCompositeFrame(i, canvasWidth, canvasHeight);
                    
                    // 转换为blob并下载
                    const blob = await new Promise(resolve => {
                        compositeCanvas.toBlob(resolve, 'image/png', 1.0);
                    });
                    
                    const fileName = `composed_frame_${i}.png`;
                    downloadImage(blob, fileName);
                    
                    await new Promise(resolve => setTimeout(resolve, 100));
                }
                
                updateProgress('合成图片保存完成！');
            } catch (error) {
                console.error('合成图片失败:', error);
                updateProgress('合成图片失败');
            }
        }
        
        // 通用下载函数
        function downloadFile(blob, fileName, fileType = 'image/png') {
            try {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 1000);
                return true;
            } catch (error) {
                console.error(`下载${fileType}失败:`, error);
                return false;
            }
        }
        
        // 下载单张图片
        function downloadImage(blob, fileName) {
            return downloadFile(blob, fileName, 'PNG图片');
        }
        
        // 获取canvas尺寸的通用函数
        function getBackgroundDimensions(animationId) {
            const anim = config.animations[animationId || state.currentAnimation];
            
            // 优先使用配置的canvas尺寸
            if (anim.canvasSize) {
                return { width: anim.canvasSize.width, height: anim.canvasSize.height };
            }
            
            // 备用：使用背景图片原始尺寸
            if (anim.frameImages[0] && anim.frameImages[0].complete) {
                return { width: anim.frameImages[0].naturalWidth, height: anim.frameImages[0].naturalHeight };
            }
            
            // 默认尺寸
            return { width: 800, height: 450 };
        }
        
        // 更新状态文本和进度的通用函数
        function updateProgress(text, progress = null) {
            dom.statusText.textContent = text;
            if (progress !== null) {
                dom.progressBar.style.width = `${progress}%`;
            }
        }
        
        // 使用gif.js保存GIF
        async function saveAsGif() {
            if (!state.userImage || !state.userImage.complete) {
                updateProgress('请先上传图片！');
                return;
            }
            
            updateProgress('正在生成GIF...', 0);
            dom.saveBtn.disabled = true;
            dom.testBtn.disabled = true; // 也禁用测试按钮
            dom.progressContainer.style.display = 'block';
            
            try {
                const anim = config.animations[state.currentAnimation];
                const { width: canvasWidth, height: canvasHeight } = getBackgroundDimensions();
                
                // 生成所有帧的canvas数组
                const frameCanvases = [];
                
                for (let i = 0; i < anim.frameCount; i++) {
                    updateProgress(`正在处理第 ${i + 1}/${anim.frameCount} 帧...`, ((i + 1) / anim.frameCount) * 30);
                    
                    const frameCanvas = await createCompositeFrame(i, canvasWidth, canvasHeight);
                    frameCanvases.push(frameCanvas);
                    
                    // 增加帧间处理延迟，避免阻塞UI
                    await new Promise(resolve => setTimeout(resolve, 50));
                }
                
                console.log(`准备生成GIF: ${frameCanvases.length}帧, 尺寸: ${canvasWidth}x${canvasHeight}`);
                
                updateProgress('正在使用gif.js生成GIF文件...', 40);
                
                const frameDelay = Math.round(200 / state.playSpeed);
                
                // petpet-js风格：智能配置优化
                const optimalConfig = getOptimalGifConfig(frameCanvases, canvasWidth, canvasHeight);
                console.log(`智能GIF配置:`, optimalConfig);
                
                // 创建gif.js实例 - 基于petpet-js的最佳实践
                const gif = new GIF({
                    workers: Math.min(navigator.hardwareConcurrency || 2, 4), // 智能worker数量
                    quality: optimalConfig.quality,
                    width: canvasWidth,
                    height: canvasHeight,
                    repeat: 0,
                    transparent: null,
                    background: '#000000',
                    dither: optimalConfig.dither,
                    globalPalette: optimalConfig.globalPalette,
                    debug: false
                });
                
                // 设置进度回调
                gif.on('progress', function(p) {
                    const progress = 40 + (p * 50);
                    updateProgress(`生成GIF中... ${Math.round(progress)}%`, progress);
                });
                
                // 设置完成回调
                gif.on('finished', function(blob) {
                    console.log(`gif.js成功生成GIF: ${(blob.size/1024).toFixed(1)}KB`);
                    
                    // 成功生成GIF
                    const fileName = `${anim.name.replace(/\s+/g, '_')}_动画_${state.playSpeed}x速度.gif`;
                    const success = downloadFile(blob, fileName, 'GIF动画');
                    
                    if (success) {
                        updateProgress('GIF保存成功！', 100);
                        console.log(`GIF下载成功: ${fileName}, 大小: ${(blob.size / 1024 / 1024).toFixed(2)}MB`);
                    } else {
                        updateProgress('下载失败，请重试');
                    }
                    
                    setTimeout(resetSaveButton, 2000);
                });
                
                // 设置错误回调
                gif.on('error', function(error) {
                    console.error('gif.js生成失败:', error);
                    updateProgress('GIF生成失败，正在下载图片序列...');
                    downloadFrameSequence(frameCanvases, anim.name);
                });
                
                // petpet-js风格：批量添加帧，确保数据一致性
                await addFramesBatch(gif, frameCanvases, frameDelay);
                
                // 开始渲染
                console.log('开始gif.js渲染...');
                gif.render();
                
            } catch (error) {
                console.error('GIF生成失败:', error);
                updateProgress(`GIF生成失败: ${error.message}`);
                resetSaveButton();
            }
        }
        
        // 创建合成帧 - 基于petpet-js的最佳实践
        async function createCompositeFrame(frameIndex, canvasWidth, canvasHeight) {
            const anim = config.animations[state.currentAnimation];
            
            // 创建独立的离屏canvas，避免DOM干扰
            const compositeCanvas = document.createElement('canvas');
            compositeCanvas.width = canvasWidth;
            compositeCanvas.height = canvasHeight;
            const ctx = compositeCanvas.getContext('2d', { 
                alpha: false, // 禁用透明度通道
                willReadFrequently: false,
                desynchronized: true // 提高性能
            });
            
            // petpet-js风格：确保画布完全清洁
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0); // 重置变换矩阵
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            // 设置一致的黑色背景，避免透明度问题
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            ctx.restore();
            
            // petpet-js风格：优化渲染质量设置
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';
            ctx.textRenderingOptimization = 'optimizeQuality';
            
            // 绘制背景图片 - 确保像素完美对齐
            if (anim.frameImages[frameIndex] && anim.frameImages[frameIndex].complete) {
                const bgImg = anim.frameImages[frameIndex];
                
                ctx.save();
                // 使用整数坐标避免亚像素渲染
                ctx.drawImage(bgImg, 0, 0, canvasWidth, canvasHeight);
                ctx.restore();
            }
            
            // 绘制用户图片 - petpet-js风格的精确定位
            if (state.processedUserImage && state.processedUserImage.complete) {
                const pos = anim.overlayPositions[frameIndex];
                
                ctx.save();
                
                // 使用整数坐标避免模糊
                const exactX = Math.round(pos.x);
                const exactY = Math.round(pos.y);
                const exactWidth = Math.round(state.processedUserImage.width * pos.scale);
                const exactHeight = Math.round(state.processedUserImage.height * pos.scale);
                
                ctx.translate(exactX, exactY);
                ctx.rotate(pos.rotation * Math.PI / 180);
                
                // 精确绘制，避免亚像素问题
                ctx.drawImage(
                    state.processedUserImage,
                    Math.round(-exactWidth/2),
                    Math.round(-exactHeight/2),
                    exactWidth,
                    exactHeight
                );
                
                ctx.restore();
                
                console.log(`精确帧${frameIndex}: 位置(${exactX}, ${exactY}), 尺寸${exactWidth}x${exactHeight}`);
            }
            
            // 强制渲染完成，确保数据一致性
            ctx.getImageData(0, 0, 1, 1); // 触发渲染完成
            
            return compositeCanvas;
        }
        
        
        // 下载帧序列
        async function downloadFrameSequence(frameCanvases, animName) {
            for (let i = 0; i < frameCanvases.length; i++) {
                const canvas = frameCanvases[i];
                const blob = await new Promise(resolve => {
                    canvas.toBlob(resolve, 'image/png', 1.0);
                });
                
                const fileName = `${animName.replace(/\s+/g, '_')}_frame_${i}.png`;
                downloadFile(blob, fileName, 'PNG图片');
                
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            updateProgress('图片序列下载完成！请使用其他工具制作GIF', 100);
            setTimeout(resetSaveButton, 3000);
        }
        
        // petpet-js风格：智能GIF配置优化
        function getOptimalGifConfig(frameCanvases, width, height) {
            // 分析第一帧的颜色复杂度
            const sampleCanvas = frameCanvases[0];
            const ctx = sampleCanvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, Math.min(width, 100), Math.min(height, 100));
            const colorComplexity = analyzeColorComplexity(imageData);
            
            console.log(`颜色复杂度分析: ${colorComplexity.type}, 唯一颜色: ${colorComplexity.uniqueColors}`);
            
            // 基于内容类型智能选择配置
            let config = {
                quality: state.gifQuality,
                dither: state.ditherMethod,
                globalPalette: true
            };
            
            // petpet-js风格：内容自适应优化
            if (colorComplexity.type === 'simple') {
                // 简单图形：禁用抖动，使用局部调色板
                config.dither = false;
                config.globalPalette = false;
                config.quality = Math.min(state.gifQuality, 5); // 提高质量
            } else if (colorComplexity.type === 'gradient') {
                // 渐变图形：使用Floyd-Steinberg抖动
                config.dither = 'FloydSteinberg-serpentine';
                config.globalPalette = true;
            } else if (colorComplexity.type === 'photo') {
                // 照片类：使用Atkinson抖动减少噪点
                config.dither = 'Atkinson-serpentine';
                config.globalPalette = true;
            }
            
            // 如果用户手动选择了抖动方法，优先使用用户选择
            if (state.ditherMethod !== 'Atkinson-serpentine') {
                config.dither = state.ditherMethod;
            }
            
            return config;
        }
        
        // 分析图像颜色复杂度
        function analyzeColorComplexity(imageData) {
            const pixels = imageData.data;
            const colorSet = new Set();
            let gradientScore = 0;
            
            // 采样分析（提高性能）
            for (let i = 0; i < pixels.length; i += 16) { // 每4个像素采样一次
                const r = pixels[i];
                const g = pixels[i + 1];
                const b = pixels[i + 2];
                const color = (r << 16) | (g << 8) | b;
                colorSet.add(color);
                
                // 检测渐变（相邻像素颜色差异）
                if (i > 16) {
                    const prevR = pixels[i - 16];
                    const prevG = pixels[i - 15];
                    const prevB = pixels[i - 14];
                    const colorDiff = Math.abs(r - prevR) + Math.abs(g - prevG) + Math.abs(b - prevB);
                    if (colorDiff > 10 && colorDiff < 100) {
                        gradientScore++;
                    }
                }
            }
            
            const uniqueColors = colorSet.size;
            const gradientRatio = gradientScore / (pixels.length / 16);
            
            // 分类内容类型
            let type;
            if (uniqueColors < 64 && gradientRatio < 0.1) {
                type = 'simple'; // 简单平面图形
            } else if (gradientRatio > 0.3) {
                type = 'gradient'; // 包含渐变
            } else {
                type = 'photo'; // 照片或复杂图形
            }
            
            return {
                type,
                uniqueColors,
                gradientRatio: Math.round(gradientRatio * 100) / 100
            };
        }
        
        // petpet-js风格：批量添加帧，优化性能和质量
        async function addFramesBatch(gif, frameCanvases, frameDelay) {
            const batchSize = 3; // 每批处理3帧，避免内存压力
            let lastFrameHash = null;
            
            for (let i = 0; i < frameCanvases.length; i += batchSize) {
                const batch = frameCanvases.slice(i, i + batchSize);
                
                for (let j = 0; j < batch.length; j++) {
                    const canvas = batch[j];
                    const frameIndex = i + j;
                    
                    // 创建完全独立的canvas副本
                    const independentCanvas = createIndependentFrame(canvas);
                    
                    // petpet-js风格：帧去重优化（可选）
                    const frameHash = getFrameHash(independentCanvas);
                    if (frameHash !== lastFrameHash) {
                        gif.addFrame(independentCanvas, { 
                            delay: frameDelay,
                            copy: true,
                            dispose: 2 // 重要：确保帧间不互相影响
                        });
                        lastFrameHash = frameHash;
                        console.log(`添加唯一帧 ${frameIndex + 1}/${frameCanvases.length}`);
                    } else {
                        console.log(`跳过重复帧 ${frameIndex + 1}`);
                    }
                }
                
                // 批间延迟，让浏览器有时间处理其他任务
                if (i + batchSize < frameCanvases.length) {
                    await new Promise(resolve => setTimeout(resolve, 10));
                }
            }
        }
        
        // 创建完全独立的帧副本
        function createIndependentFrame(sourceCanvas) {
            const independentCanvas = document.createElement('canvas');
            independentCanvas.width = sourceCanvas.width;
            independentCanvas.height = sourceCanvas.height;
            
            const ctx = independentCanvas.getContext('2d', { 
                alpha: false,
                willReadFrequently: false 
            });
            
            // 确保完全清洁的背景
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, independentCanvas.width, independentCanvas.height);
            
            // 精确复制源画布
            ctx.drawImage(sourceCanvas, 0, 0);
            
            // 强制完成渲染
            ctx.getImageData(0, 0, 1, 1);
            
            return independentCanvas;
        }
        
        // 简单的帧哈希，用于去重
        function getFrameHash(canvas) {
            const ctx = canvas.getContext('2d');
            // 采样关键像素点生成简单哈希
            const samples = [
                ctx.getImageData(0, 0, 1, 1).data,
                ctx.getImageData(canvas.width/2, canvas.height/2, 1, 1).data,
                ctx.getImageData(canvas.width-1, canvas.height-1, 1, 1).data
            ];
            
            return samples.map(s => `${s[0]}-${s[1]}-${s[2]}`).join('|');
        }
        
        // 重置保存按钮状态
        function resetSaveButton() {
            dom.saveBtn.disabled = false;
            dom.testBtn.disabled = false; // 重新启用测试按钮
            dom.progressContainer.style.display = 'none';
            dom.progressBar.style.width = '0%';
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', init);
    </script>
</body>
</html>